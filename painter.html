<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Sequencer</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #1c1e21;
            --text-secondary-color: #606770;
            --primary-color: #1877f2;
            --primary-hover-color: #166fe5;
            --secondary-color: #42b72a;
            --secondary-hover-color: #36a420;
            --danger-color: #fa383e;
            --warning-color: #ffc107;
            --warning-hover-color: #e0ac00;
            --border-color: #dddfe2;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        body { font-family: var(--font-family); line-height: 1.6; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 24px; }
        .container { max-width: 1200px; margin: 0 auto; display: flex; flex-direction: column; gap: 24px; }
        .card { background-color: var(--surface-color); box-shadow: var(--shadow); border-radius: 8px; padding: 20px; position: relative; }
        .card-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px; flex-wrap: wrap; gap: 10px; }
        .card-header h2, .card h3 { border: none; padding: 0; margin: 0; display: flex; align-items: center; gap: 8px; }
        .card-header .legend { color: var(--text-secondary-color); font-size: 0.9em; white-space: nowrap; margin-left: auto; }
        .header-controls { display: contents; }
        #progress-percentage { font-weight: 600; color: var(--primary-color); margin-left: auto; padding: 0 10px;}
        #target-part-select { padding: 4px 8px; border-radius: 6px; border: 1px solid var(--border-color); font-size: 0.9em; }
        h1 { font-size: 1.8rem; margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px;}
        .intro-text { font-size: 1rem; color: var(--text-secondary-color); margin: -10px 0 20px 0; }
        .title-input { font-size: 1.2rem; font-weight: 600; border: none; border-bottom: 2px solid transparent; width: 100%; padding: 4px; margin-bottom: 20px; transition: border-color 0.2s; }
        .title-input:focus { outline: none; border-bottom-color: var(--primary-color); }
        .setup-container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
        .input-group { display: flex; gap: 8px; margin-bottom: 15px; }
        .input-group input { flex-grow: 1; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 1rem; }
        .input-group button { white-space: nowrap; }
        button { padding: 10px 18px; background-color: var(--primary-color); color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: background-color 0.2s, opacity 0.2s; }
        button:hover { background-color: var(--primary-hover-color); }
        button:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        .btn-add, #save-file-btn.unsaved { background-color: var(--secondary-color); }
        .btn-add:hover, #save-file-btn.unsaved:hover { background-color: var(--secondary-hover-color); }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: #e03238; }
        .btn-warning { background-color: var(--warning-color); color: var(--text-color); }
        .btn-warning:hover { background-color: var(--warning-hover-color); }
        .item-list { list-style-type: none; padding: 0; display: flex; flex-wrap: wrap; gap: 10px; }
        .item-list li { display: flex; align-items: center; background-color: var(--bg-color); border-radius: 15px; padding: 5px 5px 5px 12px; font-size: 0.9rem; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .editable-name { cursor: text; padding: 2px 4px; border-radius: 3px; }
        .editable-name[contenteditable]:focus { outline: 2px solid var(--primary-color); background-color: #eaf3ff; }
        .remove-btn { background: #ccc; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; line-height: 20px; text-align: center; cursor: pointer; margin-left: 8px; font-weight: bold; transition: background-color 0.2s; }
        .remove-btn:hover { background-color: #a0a0a0; }
        .part-sequence-row { display: flex; align-items: center; gap: 15px; padding: 12px 0; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        .part-sequence-row:last-child { border-bottom: none; }
        .part-name-label { font-weight: 600; width: 150px; flex-shrink: 0; }
        .sequence-steps { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; flex-grow: 1; }
        .paint-step { display: flex; align-items: center; gap: 6px; background: #e4e6eb; border-radius: 6px; padding: 4px; position: relative; }
        .reorder-btn { display: inline-flex; align-items: center; justify-content: center; background: none; border: 1px solid #ccc; color: #888; border-radius: 50%; width: 22px; height: 22px; padding: 0; font-size: 14px; line-height: 1; text-align: center; cursor: pointer; transition: all 0.2s; }
        .reorder-btn:hover { background-color: #ddd; border-color: #aaa; color: #333; }
        .paint-step .remove-step-btn { color: #aaa; cursor: pointer; font-weight: bold; padding: 0 4px; }
        .paint-step .remove-step-btn:hover { color: var(--danger-color); }
        #stamp-tool-btn { background-color: var(--warning-color); color: var(--text-color); }
        #stamp-tool-btn:hover { background-color: var(--warning-hover-color); }
        #output { border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; background: #f8f9fa; min-height: 100px; transition: opacity 0.3s; }
        .step-wrapper { padding: 10px 0; border-bottom: 1px solid var(--border-color); transition: background-color 0.3s, border 0.3s; }
        .step-wrapper:last-child { border-bottom: none; }
        .step-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .start-indicator { font-size: 1.5rem; line-height: 1; width: 24px; text-align: center; cursor: help;}
        .start-indicator.success { color: var(--secondary-color); }
        .start-indicator.full { color: var(--warning-color); }
        .start-indicator.partial { color: var(--primary-color); }
        .start-indicator.stop { color: var(--danger-color); }
        .step-action { font-weight: 600; flex-grow: 1; }
        .check-all-label { white-space: nowrap; font-size: 0.9em; color: var(--text-secondary-color); }
        .check-all-label input { margin-right: 4px; }
        .output-color-name { background: #eee; padding: 2px 8px; border-radius: 4px; font-family: monospace; }
        .parts-checklist { list-style-type: none; padding-left: 48px; margin: 0 0 8px 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px; }
        .part-item { color: var(--text-color); }
        .part-item input { margin-right: 8px; transform: scale(1.1); }
        .part-item.waiting { color: var(--text-secondary-color); font-style: italic; }
        .part-item.waiting input { cursor: not-allowed; }
        .part-item.completed { text-decoration: line-through; }
        .step-wrapper.is-completed { opacity: 0.6; }
        .step-wrapper.is-target-path { border-left: 4px solid var(--warning-color); background-color: #fffbeb; padding-left: 10px; }
        .completion-notices { padding-left: 48px; font-size: 0.9em; }
        .completion-notice { display: flex; align-items: flex-start; color: var(--text-secondary-color); }
        .completion-notice span { line-height: 1.4; padding-right: 5px; }
        #output-section.invalidated #output { opacity: 0.4; }
        #output-section.invalidated::after { content: 'Schedule outdated. Please regenerate.'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(255, 255, 100, 0.85); border: 1px solid #e0e060; padding: 10px 20px; border-radius: 6px; font-weight: 600; text-align: center; }
        .controls-group { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 15px; }
        .controls-header { text-align: center; color: var(--text-secondary-color); width: 100%; margin: 10px 0 -5px 0; }
        #share-feedback, #file-op-feedback { color: var(--secondary-color); font-weight: 600; opacity: 0; transition: opacity 0.3s; text-align: center;}
        #file-info-bar { text-align: center; margin-top: 15px; }
        #file-info-display { font-size: 0.9em; color: var(--text-secondary-color); }
        #stamp-tool-toolbar { display: none; background-color: var(--bg-color); padding: 15px; border-radius: 6px; margin-bottom: 20px; align-items: center; gap: 15px; border: 1px solid var(--border-color); }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 10; display: none; }
        .modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--surface-color); border-radius: 8px; z-index: 20; width: 90%; max-width: 800px; max-height: 90vh; display: flex; flex-direction: column; }
        .modal-header { padding: 15px 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .modal-header h3 { margin: 0; }
        .modal-close { font-size: 24px; font-weight: bold; background: none; border: none; cursor: pointer; padding: 0 5px; color: var(--text-color); }
        .modal-content { padding: 20px; overflow-y: auto; }
        .modal-tabs { display: flex; border-bottom: 1px solid var(--border-color); }
        .modal-tab { padding: 10px 15px; cursor: pointer; border: none; background: none; font-size: 1rem; border-bottom: 3px solid transparent; color: var(--text-color); }
        .modal-tab.active { border-bottom-color: var(--primary-color); font-weight: 600; }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }
        .tab-pane h4 { margin-top: 0; }
        .tab-pane textarea, .tab-pane pre { width: 100%; min-height: 200px; max-height: 40vh; font-family: monospace; font-size: 0.9rem; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; box-sizing: border-box; }
        .tab-pane pre { background-color: var(--bg-color); white-space: pre-wrap; word-wrap: break-word; overflow: auto; }
        .modal-footer { margin-top: 15px; display: flex; justify-content: flex-end; gap: 10px; }
        #json-status { margin-top: 10px; font-weight: bold; }
        #json-status.error { color: var(--danger-color); }
        #unused-items-warning { margin-top: 20px; padding: 15px; border-radius: 6px; background-color: #fffbe6; border: 1px solid var(--warning-color); }
        #unused-items-warning h4 { margin-top: 0; margin-bottom: 10px; color: #9c6f00; }
        #unused-items-warning ul { margin: 0; padding-left: 20px; font-size: 0.9em; }
        #part-status-container { margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color); }
        #part-status-list { list-style-type: none; padding: 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px; }
        .part-status-item { display: flex; flex-direction: column; gap: 8px; background-color: var(--bg-color); padding: 12px; border-radius: 6px; border-left: 4px solid var(--border-color); }
        .part-status-item.is-complete { border-left-color: var(--secondary-color); background-color: #f6fff5; }
        .part-status-item .part-name { font-weight: 600; }
        .part-status-item progress { width: 100%; height: 8px; border-radius: 4px; }
        .part-status-item progress::-webkit-progress-bar { background-color: #e0e0e0; border-radius: 4px; }
        .part-status-item progress::-webkit-progress-value { background-color: var(--primary-color); border-radius: 4px; transition: width 0.3s ease; }
        .part-status-item.is-complete progress::-webkit-progress-value { background-color: var(--secondary-color); }
        .part-status-item .part-progress-info { display: flex; justify-content: space-between; font-size: 0.85em; color: var(--text-secondary-color); }
        .part-progress-info .status-ready { font-weight: 600; color: var(--secondary-color); }
        .part-progress-info .status-blocked { font-weight: 600; color: var(--danger-color); }
        .add-paint-target { width: 22px; height: 22px; border-radius: 50%; border: 1px dashed #aaa; background-color: #f0f0f0; color: #777; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold; line-height: 1; transition: all 0.2s;}
        .add-paint-target:hover { background-color: var(--warning-color); border-style: solid; color: var(--text-color); }
        #paint-select-popup { display: none; position: absolute; background: var(--surface-color); border: 1px solid var(--border-color); box-shadow: var(--shadow); border-radius: 6px; z-index: 100; max-height: 250px; overflow-y: auto; }
        #paint-select-popup ul { list-style: none; padding: 5px; margin: 0; }
        #paint-select-popup li { padding: 8px 12px; cursor: pointer; border-radius: 4px; }
        #paint-select-popup li:hover { background-color: var(--bg-color); }
        #paint-select-popup li.last-used { background-color: #eaf3ff; border-bottom: 1px solid var(--border-color); margin-bottom: 5px; font-weight: 600; color: var(--primary-color); }
        .help-icon { display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 50%; background-color: #ced4da; color: white; font-size: 12px; font-weight: bold; cursor: help; user-select: none; }
        #global-help-tooltip { visibility: hidden; opacity: 0; position: absolute; background-color: #343a40; color: white; padding: 8px 12px; border-radius: 6px; z-index: 200; font-size: 0.9rem; line-height: 1.5; max-width: 300px; transition: opacity 0.2s; pointer-events: none; }
        #paint-usage-list { list-style-type: none; padding: 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 15px; margin-top: 20px;}
        .paint-usage-item { background-color: var(--bg-color); padding: 15px; border-radius: 6px; }
        .paint-usage-item h4 { margin: 0 0 10px 0; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; }
        .paint-usage-item ul { list-style-type: none; padding: 0; margin: 0; font-size: 0.9em; column-count: 2; column-gap: 15px; }
        .paint-usage-item .unused-text { font-style: italic; color: var(--text-secondary-color); font-size: 0.9em; margin: 0; }
        
        #welcome-card h2, #welcome-card p { text-align: center; justify-content: center; }
        
        .container.is-welcome .app-card { display: none; }
        .container:not(.is-welcome) #welcome-card { display: none; }

        @media (max-width: 900px) {
            .setup-container { grid-template-columns: 1fr; }
            .part-sequence-row { flex-direction: column; align-items: flex-start; }
            .controls-group { flex-direction: column; }
            .paint-usage-item ul { column-count: 1; }
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="card app-card">
            <h1>🎨 Paint Sequencer</h1>
            <p class="intro-text">This tool helps you find the most efficient painting order for your projects. Add paints and parts, define sequences, then generate the schedule.</p>
            <input type="text" id="title-input" class="title-input" placeholder="Enter Project Title">
        </div>
        
        <div id="welcome-card" class="card">
            <h2>Welcome to the Paint Sequencer!</h2>
            <p>This tool helps you find the most efficient painting order for your projects.<br>How would you like to begin?</p>
            <div class="controls-group">
                <button id="start-blank-btn">🚀 Start a New Blank Project</button>
                <button id="load-example-btn" class="btn-warning">📚 Load an Example Project</button>
                <button id="load-file-welcome-btn">📂 Load File from Device</button>
                <button id="import-json-welcome-btn">✍️ Paste JSON from Text</button>
            </div>
        </div>

        <div class="card app-card">
            <h3>Project File <span class="help-icon" data-help-text="Load, save, or share your project file. 'Save to Device' will remember the file location for quick subsequent saves. 'Import/Export' is for raw JSON text.">?</span></h3>
            <div class="controls-group">
                <button id="load-file-btn">📂 Load from Device</button>
                <button id="save-file-btn">💾 Save to Device</button>
                <button id="import-export-btn">📤 Import/Export (JSON)</button>
                <button id="share-btn">🔗 Share (Copy Link)</button>
            </div>
            <div id="file-info-bar">
                <p id="file-info-display"></p>
                <span id="share-feedback"></span>
                <span id="file-op-feedback"></span>
            </div>
        </div>
        
        <div class="card app-card">
            <div class="setup-container">
                <div id="paint-management">
                    <div class="card-header"><h2>Available Paints <span class="help-icon" data-help-text="Add your project's paints here. You can edit names by clicking on them, or remove items with the '×'.">?</span></h2></div>
                    <div class="input-group">
                        <input type="text" id="paint-input" placeholder="Add paints, comma-separated">
                        <button id="add-paint-btn" class="btn-add">Add</button>
                    </div>
                    <ul id="paint-list" class="item-list"></ul>
                </div>
                <div id="part-management">
                    <div class="card-header"><h2>📦 Parts to be Painted <span class="help-icon" data-help-text="Add your project's parts here. You can edit names by clicking on them, or remove items with the '×'.">?</span></h2></div>
                    <div class="input-group">
                        <input type="text" id="part-input" placeholder="Add parts, comma-separated">
                        <button id="add-part-btn" class="btn-add">Add</button>
                    </div>
                    <ul id="part-list" class="item-list"></ul>
                </div>
            </div>
        </div>

        <div class="card app-card" id="sequence-card">
            <div class="card-header">
                <h2>Assign Paint Sequence <span class="help-icon" data-help-text="Assign paints to each part by clicking the '+' buttons. Use the move arrows and remove buttons on each step. Use the Stamp Tool to quickly apply one color to many parts.">?</span></h2>
                <button id="stamp-tool-btn">🖌️ Stamp Tool</button>
            </div>
            <div id="stamp-tool-toolbar">
                <strong>Stamping with:</strong>
                <select id="stamp-color-select"></select>
                <button id="exit-stamp-btn" class="btn-danger">Finish Stamping</button>
            </div>
            <div id="part-sequence-container"></div>
            <div id="unused-items-warning" style="display: none;"></div>
        </div>
        
        <div class="card app-card">
             <h3 class="controls-header">Schedule Controls <span class="help-icon" data-help-text="Once your sequences are set, click 'Generate' to create the schedule. Use the reset buttons to clear progress or the entire project.">?</span></h3>
            <div class="controls-group">
                <button id="generate-btn">✨ Generate Optimal Order</button>
                <button id="revert-btn" class="btn-danger" style="display: none;">↩️ Revert Changes</button>
                <button id="reset-progress-btn" class="btn-warning">🔄 Reset Progress</button>
                <button id="reset-btn" class="btn-danger">💣 Reset All</button>
            </div>
        </div>

        <div class="card app-card" id="output-section">
            <div class="card-header">
                <h2>✔️ Optimized Schedule <span class="help-icon" data-help-text="Follow the schedule by checking off tasks as you complete them. Use the dropdown to highlight a part's critical path, and see the legend for icon meanings.">?</span></h2>
                <select id="target-part-select" title="Select a part to highlight its critical path"></select>
                <span id="progress-percentage"></span>
                <small class="legend">✔️ Completed, ⭐ Full, ▶️ Partial, 🛑 Blocked</small>
            </div>
            <div id="output"><p style="color: var(--text-secondary-color);">Your schedule will appear here.</p></div>
            <div id="part-status-container">
                <h3>Part Status Tracker <span class="help-icon" data-help-text="Track the real-time progress for each part. The status shows what's needed next to keep your project moving.">?</span></h3>
                <ul id="part-status-list"><li style="color: var(--text-secondary-color);">Generate a schedule to see part status.</li></ul>
            </div>
        </div>

        <div class="card app-card" id="paint-usage-card">
            <h3>Paint Usage Summary <span class="help-icon" data-help-text="A quick reference to see which parts use each paint. This list updates automatically as you edit your sequences.">?</span></h3>
            <ul id="paint-usage-list"><li style="color: var(--text-secondary-color);">Add paints and parts to see a summary.</li></ul>
        </div>
    </div>
    
    <div class="modal-overlay" id="json-modal-overlay">
        <div class="modal" id="json-modal">
            <div class="modal-header">
                <h3>Import / Export Project JSON</h3>
                <button class="modal-close" id="json-modal-close-btn">×</button>
            </div>
            <div class="modal-tabs">
                <button class="modal-tab active" data-tab="export">Export Project</button>
                <button class="modal-tab" data-tab="import">Import Project</button>
                <button class="modal-tab" data-tab="schema">JSON Schema</button>
            </div>
            <div class="modal-content">
                <div class="tab-pane active" id="tab-export">
                    <h4>Current Project JSON</h4>
                    <p>Copy this text to save your project definition to a file.</p>
                    <textarea id="json-export-area" readonly></textarea>
                    <div class="modal-footer">
                        <button id="copy-json-btn">Copy to Clipboard</button>
                    </div>
                </div>
                <div class="tab-pane" id="tab-import">
                    <h4>Import from Text</h4>
                    <textarea id="json-import-area" placeholder="Paste your project JSON here..."></textarea>
                    <h4>Import from URL</h4>
                    <div class="input-group">
                        <input type="url" id="json-import-url" placeholder="https://.../project.json">
                     </div>
                     <div id="json-status"></div>
                    <div class="modal-footer">
                        <button id="import-json-btn" class="btn-add">Load Project</button>
                    </div>
                </div>
                <div class="tab-pane" id="tab-schema">
                    <h4>Project File Schema</h4>
                    <p>Your JSON file should conform to this structure.</p>
                    <pre id="json-schema-area"></pre>
                </div>
            </div>
        </div>
    </div>

    <div id="paint-select-popup"><ul></ul></div>
    <div id="global-help-tooltip"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let state = { projectId: null, title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } };
        let fileHandle = null;
        let isPristineState = false;
        let paintIdMap = new Map();
        let nextPartId = 0;
        let nextPaintId = 0;
        let lastSelectedPaintId = null;
        let paintPopupContext = null;
        let scheduleData = { steps: [], partToSequence: new Map(), completedTasks: new Set(), currentTargetPartName: null, targetPathStepIds: new Set() };
        
        // Element caching
        const container = document.querySelector('.container');
        const shareBtn = document.getElementById('share-btn');
        const revertBtn = document.getElementById('revert-btn');
        const generateBtn = document.getElementById('generate-btn');
        const resetProgressBtn = document.getElementById('reset-progress-btn');
        const resetBtn = document.getElementById('reset-btn');
        const importExportBtn = document.getElementById('import-export-btn');
        const loadFileBtn = document.getElementById('load-file-btn');
        const saveFileBtn = document.getElementById('save-file-btn');
        const titleInput = document.getElementById('title-input');
        const paintList = document.getElementById('paint-list');
        const partList = document.getElementById('part-list');
        const partSequenceContainer = document.getElementById('part-sequence-container');
        const outputDiv = document.getElementById('output');
        const outputSection = document.getElementById('output-section');
        const progressPercentageEl = document.getElementById('progress-percentage');
        const targetPartSelect = document.getElementById('target-part-select');
        const stampToolBtn = document.getElementById('stamp-tool-btn');
        const unusedItemsWarningDiv = document.getElementById('unused-items-warning');
        const paintSelectPopup = document.getElementById('paint-select-popup');
        const globalHelpTooltip = document.getElementById('global-help-tooltip');
        const paintUsageList = document.getElementById('paint-usage-list');
        const fileInfoDisplay = document.getElementById('file-info-display');
        const fileOpFeedback = document.getElementById('file-op-feedback');

        const isFSSupported = 'showOpenFilePicker' in window;
        
        const sanitizeHTML = str => String(str).replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[match]);
        const generateId = () => Math.random().toString(36).substring(2, 9);
        const getTaskKey = (partName, colorName, index) => `${partName}__${colorName}__${index}`;

        const naturalSort = (a, b) => {
            const re = /(\d+)|(\D+)/g;
            const aParts = String(a).match(re) || [];
            const bParts = String(b).match(re) || [];
            for (let i = 0; i < Math.min(aParts.length, bParts.length); i++) {
                const aPart = aParts[i];
                const bPart = bParts[i];
                if (!isNaN(aPart) && !isNaN(bPart)) {
                    const numDiff = parseInt(aPart, 10) - parseInt(bPart, 10);
                    if (numDiff !== 0) return numDiff;
                } else if (aPart !== bPart) {
                    return aPart.localeCompare(bPart);
                }
            }
            return aParts.length - bParts.length;
        };

        function updatePaintIdMap() { paintIdMap.clear(); state.paints.forEach(paint => paintIdMap.set(paint.id, paint.name)); }
        const getPaintNameById = (id) => paintIdMap.get(id) || 'Unknown Paint';
        
        const renderAll = () => { updatePaintIdMap(); renderTitle(); renderPaintList(); renderPartList(); renderSequenceBuilder(); renderPaintUsageSummary(); };
        const renderTitle = () => { titleInput.value = state.title; document.title = state.title ? `${state.title} - Paint Sequencer` : "Paint Sequencer"; };
        
        const renderPaintList = () => {
             paintList.innerHTML = state.paints.map(p => `<li data-paint-id="${p.id}"><span class="editable-name" contenteditable="true" data-original-name="${sanitizeHTML(p.name)}">${sanitizeHTML(p.name)}</span><span class="remove-btn" data-paint-id="${p.id}" title="Remove Paint">×</span></li>`).join('');
        };
        const renderPartList = () => {
            partList.innerHTML = state.parts.map(p => `<li><span class="editable-name" contenteditable="true" data-part-id="${p.id}">${sanitizeHTML(p.name)}</span><span class="remove-btn" data-part-id="${p.id}" title="Remove Part">×</span></li>`).join('');
        };

        function renderUnusedItemsWarning() {
            const usedPaintIds = new Set();
            state.parts.forEach(part => { part.sequence.forEach(paintId => usedPaintIds.add(paintId)); });
            const unusedPaints = state.paints.filter(p => !usedPaintIds.has(p.id));
            const unusedParts = state.parts.filter(p => p.sequence.length === 0);

            if (unusedPaints.length === 0 && unusedParts.length === 0) {
                unusedItemsWarningDiv.style.display = 'none';
                return;
            }
            let html = '<h4>⚠️ Unused Items</h4>';
            if (unusedPaints.length > 0) { html += `<strong>Paints:</strong><ul>${unusedPaints.map(p => `<li>${sanitizeHTML(p.name)}</li>`).join('')}</ul>`; }
            if (unusedParts.length > 0) { html += `<strong>Parts:</strong><ul>${unusedParts.map(p => `<li>${sanitizeHTML(p.name)}</li>`).join('')}</ul>`; }
            unusedItemsWarningDiv.innerHTML = html;
            unusedItemsWarningDiv.style.display = 'block';
        }
        
        function renderSequenceBuilder() {
            partSequenceContainer.innerHTML = '';
            if (isPristineState) return;

            if (state.parts.length === 0) {
                partSequenceContainer.innerHTML = '<p style="color: var(--text-secondary-color);">Add parts to begin.</p>';
                renderUnusedItemsWarning();
                return;
            }

            state.parts.forEach(part => {
                const row = document.createElement('div');
                row.className = 'part-sequence-row';
                row.dataset.partId = part.id;
                
                const stepsContainer = document.createElement('div');
                stepsContainer.className = 'sequence-steps';

                stepsContainer.appendChild(createAddPaintTarget(part.id, 0));

                part.sequence.forEach((paintId, index) => {
                    const paintName = getPaintNameById(paintId);
                    const stepEl = document.createElement('div');
                    stepEl.className = 'paint-step';
                    stepEl.innerHTML = `<button class="reorder-btn" data-dir="left" data-index="${index}" title="Move Left">←</button><span>${sanitizeHTML(paintName)}</span><button class="reorder-btn" data-dir="right" data-index="${index}" title="Move Right">→</button><span class="remove-step-btn" data-index="${index}" title="Remove step">×</span>`;
                    stepsContainer.appendChild(stepEl);
                    stepsContainer.appendChild(createAddPaintTarget(part.id, index + 1));
                });

                row.innerHTML = `<div class="part-name-label">${sanitizeHTML(part.name)}</div>`;
                row.appendChild(stepsContainer);
                partSequenceContainer.appendChild(row);
            });
            renderUnusedItemsWarning();
        }

        function createAddPaintTarget(partId, index) {
            const el = document.createElement('div');
            el.className = 'add-paint-target';
            el.textContent = '+';
            el.dataset.partId = partId;
            el.dataset.insertIndex = index;
            el.title = 'Add paint step';
            return el;
        }
        
        function renderPaintUsageSummary() {
            paintUsageList.innerHTML = '';
            if (state.paints.length === 0) {
                paintUsageList.innerHTML = '<li style="color: var(--text-secondary-color);">Add paints to see a summary.</li>';
                return;
            }
            const items = state.paints.map(paint => {
                const partsUsingPaint = state.parts.filter(part => part.sequence.includes(paint.id)).map(part => part.name).sort(naturalSort);
                let partListHtml;
                if (partsUsingPaint.length > 0) { partListHtml = `<ul>${partsUsingPaint.map(name => `<li>${sanitizeHTML(name)}</li>`).join('')}</ul>`; }
                else { partListHtml = `<p class="unused-text">Not used in any sequence.</p>`; }
                return `<li class="paint-usage-item"><h4>${sanitizeHTML(paint.name)}</h4>${partListHtml}</li>`;
            });
            paintUsageList.innerHTML = items.join('');
        }
        
        function markAsUnsavedAndAutoSave() { saveFileBtn.classList.add('unsaved'); revertBtn.style.display = 'inline-block'; autoSaveProjectState(); }
        function markAsSaved() { saveFileBtn.classList.remove('unsaved'); revertBtn.style.display = 'none'; }
        function invalidateSchedule() { if (scheduleData.steps.length > 0) outputSection.classList.add('invalidated'); }
        function dismissWelcome() { isPristineState = false; container.classList.remove('is-welcome'); }

        function enterStampMode() {
            if (state.paints.length === 0) { alert("Please add at least one paint color before using the Stamp Tool."); return; }
            state.stampMode.isActive = true;
            document.getElementById('stamp-tool-btn').style.display = 'none';
            document.getElementById('stamp-tool-toolbar').style.display = 'flex';
            const stampColorSelect = document.getElementById('stamp-color-select');
            stampColorSelect.innerHTML = state.paints.map(p => `<option value="${p.id}">${sanitizeHTML(p.name)}</option>`).join('');
            state.stampMode.color = parseInt(stampColorSelect.value);
            renderAll();
        }

        function exitStampMode() { state.stampMode.isActive = false; document.getElementById('stamp-tool-btn').style.display = 'block'; document.getElementById('stamp-tool-toolbar').style.display = 'none'; renderAll(); }
        function handleStampColorChange(e) { state.stampMode.color = parseInt(e.target.value); }
        
        function handleTitleChange() { state.title = titleInput.value; renderTitle(); markAsUnsavedAndAutoSave(); }
        
        function handleAddItems(inputElId, collection, createItem, nameProp = 'name') {
            const inputEl = document.getElementById(inputElId);
            const values = inputEl.value.split(',').map(v => v.trim()).filter(Boolean);
            if (values.length === 0) return;
            dismissWelcome();
            values.forEach(value => { 
                const exists = collection.some(item => item[nameProp] === value);
                if (!exists) collection.push(createItem(value));
            });
            inputEl.value = ''; 
            invalidateSchedule(); 
            markAsUnsavedAndAutoSave(); 
            renderAll();
        }

        function handleAddPaint() { handleAddItems('paint-input', state.paints, value => ({ id: nextPaintId++, name: value }), 'name'); }
        function handleAddPart() { handleAddItems('part-input', state.parts, value => ({ id: nextPartId++, name: value, sequence: [] }), 'name'); }
        
        function handlePaintListClick(e) {
            if (!e.target.matches('.remove-btn')) return;
            const paintIdToRemove = parseInt(e.target.dataset.paintId);
            const paintToRemove = state.paints.find(p => p.id === paintIdToRemove);
            if (!paintToRemove) return;

            if (state.parts.some(p => p.sequence.includes(paintIdToRemove))) {
                if (!confirm(`Warning: This will remove "${paintToRemove.name}" from all part sequences. Proceed?`)) return;
                state.parts.forEach(part => { part.sequence = part.sequence.filter(pid => pid !== paintIdToRemove); });
            }
            state.paints = state.paints.filter(p => p.id !== paintIdToRemove);
            invalidateSchedule(); markAsUnsavedAndAutoSave(); renderAll();
        }

        function handlePartListClick(e) {
            if (!e.target.matches('.remove-btn')) return;
            const partId = parseInt(e.target.dataset.partId);
            const part = state.parts.find(p => p.id === partId);
            if (part && confirm(`Remove part "${part.name}"?`)) {
                state.parts = state.parts.filter(p => p.id !== partId);
                invalidateSchedule(); markAsUnsavedAndAutoSave(); renderAll();
            }
        }

        function handleNameEdit(e, listType) {
            const target = e.target;
            const saveEdit = () => {
                const newValue = target.textContent.trim();
                let oldValue;
                let isDuplicate = false; let idToUpdate;

                if (listType === 'paint') {
                    idToUpdate = parseInt(target.closest('li').dataset.paintId);
                    const paint = state.paints.find(p => p.id === idToUpdate);
                    if (!paint) return;
                    oldValue = paint.name;
                    isDuplicate = state.paints.some(p => p.name === newValue && p.id !== idToUpdate);
                } else { // part
                    idToUpdate = parseInt(target.dataset.partId);
                    const part = state.parts.find(p => p.id === idToUpdate);
                    if (!part) return;
                    oldValue = part.name;
                    isDuplicate = state.parts.some(p => p.name === newValue && p.id !== idToUpdate);
                }
                
                if (newValue === oldValue) return;
                if (!newValue) { alert("Name cannot be empty."); target.textContent = oldValue; return; }
                if (isDuplicate) { alert(`Name "${newValue}" already exists.`); target.textContent = oldValue; return; }
                
                const newCompletedTasks = new Set();
                scheduleData.completedTasks.forEach(taskKey => {
                    let [partName, paintName, index] = taskKey.split('__');
                    if (listType === 'paint' && paintName === oldValue) { paintName = newValue; } 
                    else if (listType === 'part' && partName === oldValue) { partName = newValue; }
                    newCompletedTasks.add(getTaskKey(partName, paintName, index));
                });
                scheduleData.completedTasks = newCompletedTasks;
                saveProgressToLocalStorage();

                if (listType === 'paint') {
                    const paint = state.paints.find(p => p.id === idToUpdate);
                    if (paint) paint.name = newValue;
                    scheduleData.steps.forEach(s => { if(s.color === oldValue) s.color = newValue; });
                } else { // part
                    const part = state.parts.find(p => p.id === idToUpdate);
                    if (part) part.name = newValue;
                    scheduleData.steps.forEach(s => { s.partList = s.partList.map(p => p.name === oldValue ? { ...p, name: newValue } : p); });
                    scheduleData.partToSequence.forEach((seq, key) => { if(key === oldValue) { scheduleData.partToSequence.delete(key); scheduleData.partToSequence.set(newValue, seq); }});
                    if(scheduleData.currentTargetPartName === oldValue) scheduleData.currentTargetPartName = newValue;
                }
                
                markAsUnsavedAndAutoSave();
                renderAll();
                updateScheduleView();
            };

            if (e.type === 'keydown' && (e.key === 'Enter' || e.key === 'Escape')) { e.preventDefault(); target.blur(); if (e.key === 'Escape') target.textContent = target.dataset.originalName; }
            else if (e.type === 'blur') { saveEdit(); }
        }
        
        function handleSequenceInteraction(e) {
            const partRow = e.target.closest('.part-sequence-row');
            if (!partRow) return;

            if (e.target.matches('.add-paint-target')) {
                const part = state.parts.find(p => p.id === parseInt(e.target.dataset.partId));
                if (state.stampMode.isActive) {
                    if (part) { part.sequence.splice(parseInt(e.target.dataset.insertIndex), 0, state.stampMode.color); invalidateSchedule(); markAsUnsavedAndAutoSave(); renderAll(); }
                } else { openPaintSelectPopup(e.target); }
                return;
            }

            const paintStep = e.target.closest('.paint-step');
            if(!paintStep) return;
            const part = state.parts.find(p => p.id === parseInt(partRow.dataset.partId));
            if (!part) return;
            let stateChanged = false;
            
            if (e.target.matches('.remove-step-btn')) {
                part.sequence.splice(parseInt(e.target.dataset.index), 1);
                stateChanged = true;
            } else if (e.target.matches('.reorder-btn')) {
                const index = parseInt(e.target.dataset.index);
                const dir = e.target.dataset.dir;
                if (dir === 'left' && index > 0) { [part.sequence[index], part.sequence[index - 1]] = [part.sequence[index - 1], part.sequence[index]]; stateChanged = true; } 
                else if (dir === 'right' && index < part.sequence.length - 1) { [part.sequence[index], part.sequence[index + 1]] = [part.sequence[index + 1], part.sequence[index]]; stateChanged = true; }
            }
            if (stateChanged) { invalidateSchedule(); markAsUnsavedAndAutoSave(); renderAll(); }
        }

        function openPaintSelectPopup(target) {
            if (state.paints.length === 0) { alert("Please add paints first."); return; }
            paintPopupContext = { partId: parseInt(target.dataset.partId), insertIndex: parseInt(target.dataset.insertIndex) };
            const list = paintSelectPopup.querySelector('ul');
            list.innerHTML = '';
            if(lastSelectedPaintId !== null && paintIdMap.has(lastSelectedPaintId)) {
                const li = document.createElement('li');
                li.dataset.paintId = lastSelectedPaintId; li.className = 'last-used'; li.textContent = `Last Used: ${getPaintNameById(lastSelectedPaintId)}`;
                list.appendChild(li);
            }
            state.paints.forEach(paint => {
                if (paint.id === lastSelectedPaintId) return;
                const li = document.createElement('li');
                li.dataset.paintId = paint.id; li.textContent = paint.name;
                list.appendChild(li);
            });
            const rect = target.getBoundingClientRect();
            paintSelectPopup.style.left = `${rect.left + window.scrollX}px`;
            paintSelectPopup.style.top = `${rect.bottom + window.scrollY + 5}px`;
            paintSelectPopup.style.display = 'block';
            paintSelectPopup.scrollTop = 0;
        }

        function closePaintSelectPopup() { paintSelectPopup.style.display = 'none'; paintPopupContext = null; }
        function handlePaintSelect(e) {
            if (!paintPopupContext) return;
            const targetLi = e.target.closest('li[data-paint-id]');
            if (!targetLi) return;
            const paintId = parseInt(targetLi.dataset.paintId);
            const part = state.parts.find(p => p.id === paintPopupContext.partId);
            if (part) { part.sequence.splice(paintPopupContext.insertIndex, 0, paintId); lastSelectedPaintId = paintId; markAsUnsavedAndAutoSave(); renderAll(); }
            closePaintSelectPopup();
        }

        function generateOptimalOrder() {
            _resetSchedule(false);
            if (isPristineState || state.parts.length === 0) {
                outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">Your schedule will appear here.</p>'; 
                document.getElementById('part-status-list').innerHTML = `<li style="color: var(--text-secondary-color);">No sequenced parts to track.</li>`;
                return;
            }
            let partsToProcess = JSON.parse(JSON.stringify(state.parts)).filter(p => p.sequence.length > 0).map(p => ({ ...p, currentStep: 0 }));
            if (partsToProcess.length === 0) {
                outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">No parts with paint sequences.</p>'; 
                document.getElementById('part-status-list').innerHTML = `<li style="color: var(--text-secondary-color);">No sequenced parts to track.</li>`;
                return;
            }
            let stepIdCounter = 0;
            while (partsToProcess.some(p => p.currentStep < p.sequence.length)) {
                const readyPartsByColor = new Map();
                partsToProcess.filter(p => p.currentStep < p.sequence.length).forEach(part => {
                    const nextPaintId = part.sequence[part.currentStep];
                    if (!readyPartsByColor.has(nextPaintId)) readyPartsByColor.set(nextPaintId, []);
                    readyPartsByColor.get(nextPaintId).push(part);
                });
                let priorityChoices = [], lastStepChoices = [];
                for (const [paintId, partList] of readyPartsByColor.entries()) { (partList.some(p => p.currentStep < p.sequence.length - 1) ? priorityChoices : lastStepChoices).push({ paintId, partList, count: partList.length }); }
                const choices = priorityChoices.length > 0 ? priorityChoices : lastStepChoices;
                choices.sort((a, b) => b.count - a.count);
                if (choices.length === 0) break;
                const bestChoice = choices[0];
                const stepId = stepIdCounter++, colorName = getPaintNameById(bestChoice.paintId);
                const stepParts = bestChoice.partList.map(p => ({ name: p.name, index: p.currentStep }));
                scheduleData.steps.push({ id: stepId, color: colorName, partList: stepParts });
                bestChoice.partList.forEach(part => { part.currentStep++; });
            }
            state.parts.forEach(part => { scheduleData.partToSequence.set(part.name, part.sequence.map(getPaintNameById)); });
            outputSection.classList.remove('invalidated'); renderTargetPartSelector(); updateScheduleView();
        }
        
        function renderTargetPartSelector() {
            targetPartSelect.innerHTML = '<option value="">Default (No Target)</option>';
            const sortedPartNames = Array.from(scheduleData.partToSequence.keys()).sort(naturalSort);
            sortedPartNames.forEach(name => { targetPartSelect.innerHTML += `<option value="${sanitizeHTML(name)}">${sanitizeHTML(name)}</option>`; });
            targetPartSelect.value = scheduleData.currentTargetPartName || "";
        }
        
        function updateTargetPath() {
            scheduleData.targetPathStepIds.clear();
            const { currentTargetPartName, partToSequence, steps } = scheduleData;
            if (!currentTargetPartName) return;
            const targetSequence = partToSequence.get(currentTargetPartName);
            if (!targetSequence) return;
            let requiredTasks = new Set(targetSequence.map((color, index) => getTaskKey(currentTargetPartName, color, index)));
            let toProcess = [...requiredTasks];
            while (toProcess.length > 0) {
                const taskKey = toProcess.pop();
                const [partName, , indexStr] = taskKey.split('__'); const index = parseInt(indexStr);
                const sequence = partToSequence.get(partName);
                if(!sequence || index === 0) continue;
                const prereqIndex = index - 1, prereqColor = sequence[prereqIndex];
                const prereqTaskKey = getTaskKey(partName, prereqColor, prereqIndex);
                if (!requiredTasks.has(prereqTaskKey)) { requiredTasks.add(prereqTaskKey); toProcess.push(prereqTaskKey); }
            }
            steps.forEach(step => { for (const partInfo of step.partList) { if (requiredTasks.has(getTaskKey(partInfo.name, step.color, partInfo.index))) { scheduleData.targetPathStepIds.add(step.id); break; } } });
        }
        
        function isPartStartable(partName, index) {
            if (index === 0) return true;
            const sequence = scheduleData.partToSequence.get(partName);
            if (!sequence || index >= sequence.length) return false;
            const prereqIndex = index - 1, prereqColor = sequence[prereqIndex];
            return scheduleData.completedTasks.has(getTaskKey(partName, prereqColor, prereqIndex));
        }

        function createStepWrapper(stepInfo) {
            const wrapper = document.createElement('div');
            wrapper.className = 'step-wrapper';
            let indicatorIcon, indicatorTitle, indicatorClass;
            const remaining = stepInfo.partList.length - stepInfo.completedCount;
            if (remaining === 0) { indicatorIcon = '✔️'; indicatorTitle = 'Step completed.'; indicatorClass = 'success'; wrapper.classList.add('is-completed'); }
            else if (stepInfo.startableCount === remaining) { indicatorIcon = '⭐'; indicatorTitle = 'All remaining parts are ready.'; indicatorClass = 'full'; }
            else if (stepInfo.startableCount > 0) { indicatorIcon = '▶️'; indicatorTitle = 'Some parts are ready.'; indicatorClass = 'partial'; }
            else { indicatorIcon = '🛑'; indicatorTitle = 'No parts are ready yet.'; indicatorClass = 'stop'; }
            if(scheduleData.targetPathStepIds.has(stepInfo.id)) wrapper.classList.add('is-target-path');
            let countText = (stepInfo.startableCount > 0 && remaining > 0) ? ` (${stepInfo.startableCount} of ${remaining} ready)` : '';
            wrapper.innerHTML = `<div class="step-header"><span class="start-indicator ${indicatorClass}" title="${sanitizeHTML(indicatorTitle)}">${indicatorIcon}</span><span class="step-action">Load <code class="output-color-name">${sanitizeHTML(stepInfo.color)}</code>${countText}</span><label class="check-all-label"><input type="checkbox" class="master-checkbox" data-step-id="${stepInfo.id}" ${stepInfo.startableCount === 0 ? 'disabled' : ''}> Check All Ready</label></div><ul class="parts-checklist">${generatePartListHTML(stepInfo)}</ul><div class="completion-notices">${generateCompletionNoticesHTML(stepInfo)}</div>`;
            return wrapper;
        }

        function createMergedStepWrapper(stepGroup) {
            const wrapper = document.createElement('div');
            wrapper.className = 'step-wrapper';
            const allOriginalIds = stepGroup.map(s => s.id);
            if(allOriginalIds.some(id => scheduleData.targetPathStepIds.has(id))) wrapper.classList.add('is-target-path');
            const totalStartable = stepGroup.reduce((sum, s) => sum + s.startableCount, 0), totalRemaining = stepGroup.reduce((sum, s) => sum + (s.partList.length - s.completedCount), 0);
            let countText = ` (${totalStartable} of ${totalRemaining} ready)`;
            const masterCheck = `<label class="check-all-label"><input type="checkbox" class="master-checkbox" data-original-step-ids="${allOriginalIds.join(',')}" ${totalStartable === 0 ? 'disabled' : ''}> Check All Ready</label>`;
            const partListHTML = stepGroup.map(generatePartListHTML).join(''), noticesHTML = stepGroup.map(generateCompletionNoticesHTML).join('');
            wrapper.innerHTML = `<div class="step-header"><span class="start-indicator full" title="All remaining parts are ready.">⭐</span><span class="step-action">Load <code class="output-color-name">${sanitizeHTML(stepGroup[0].color)}</code>${countText}</span>${masterCheck}</div><ul class="parts-checklist">${partListHTML}</ul><div class="completion-notices">${noticesHTML}</div>`;
            return wrapper;
        }
        
        function generatePartListHTML(stepInfo) {
            const sortedPartList = [...stepInfo.partList].sort((a,b) => naturalSort(a.name, b.name));
            return sortedPartList.map(partInfo => {
                const { name, index } = partInfo;
                const taskKey = getTaskKey(name, stepInfo.color, index), isCompleted = scheduleData.completedTasks.has(taskKey), canStart = !isCompleted && isPartStartable(name, index);
                let classes = 'part-item'; if (isCompleted) classes += ' completed'; if (!canStart && !isCompleted) classes += ' waiting';
                return `<li class="${classes}"><label><input type="checkbox" class="part-checkbox" data-part-name="${sanitizeHTML(name)}" data-color="${sanitizeHTML(stepInfo.color)}" data-index="${index}" ${isCompleted ? 'checked' : ''} ${!canStart && !isCompleted ? 'disabled' : ''}>${sanitizeHTML(name)}</label></li>`;
            }).join('');
        }
        
        function generateCompletionNoticesHTML(stepInfo) {
            let html = ''; const willCompleteParts = [], didCompleteParts = [];
            stepInfo.partList.forEach(partInfo => {
                const { name, index } = partInfo; const sequence = scheduleData.partToSequence.get(name);
                if (sequence && index === sequence.length - 1) { const taskKey = getTaskKey(name, stepInfo.color, index); if (scheduleData.completedTasks.has(taskKey)) didCompleteParts.push(name); else willCompleteParts.push(name); }
            });
            if (willCompleteParts.length > 0) html += `<div class="completion-notice"><span>🏆</span><div>Will complete: <strong>${willCompleteParts.map(sanitizeHTML).sort(naturalSort).join(', ')}</strong></div></div>`;
            if (didCompleteParts.length > 0) html += `<div class="completion-notice"><span>✔️</span><div>Completed: <strong>${didCompleteParts.map(sanitizeHTML).sort(naturalSort).join(', ')}</strong></div></div>`;
            return html;
        }

        function renderPartStatusTracker() {
            const partStatusList = document.getElementById('part-status-list');
            const sequencedParts = state.parts.filter(p => p.sequence.length > 0);
            if (sequencedParts.length === 0) { partStatusList.innerHTML = `<li style="color: var(--text-secondary-color);">No sequenced parts to track.</li>`; return; }
            const items = sequencedParts.sort((a,b) => naturalSort(a.name, b.name)).map(part => {
                const sequence = scheduleData.partToSequence.get(part.name) || [], totalSteps = sequence.length, firstUncompletedIndex = sequence.findIndex((color, index) => !scheduleData.completedTasks.has(getTaskKey(part.name, color, index)));
                let progressValue, statusText, itemClass = '';
                if(firstUncompletedIndex === -1 && totalSteps > 0) { progressValue = totalSteps; statusText = '<span class="status-ready">✅ Completed!</span>'; itemClass = 'is-complete' }
                else if (totalSteps > 0) { progressValue = firstUncompletedIndex; const nextPaintName = sequence[firstUncompletedIndex], isReady = isPartStartable(part.name, firstUncompletedIndex); statusText = `Next: <strong>${sanitizeHTML(nextPaintName)}</strong> ${isReady ? '<span class="status-ready">(Ready)</span>' : '<span class="status-blocked">(Blocked)</span>'}`; }
                else { progressValue = 0; statusText = 'No sequence defined.'; }
                return `<li class="part-status-item ${itemClass}"><span class="part-name">${sanitizeHTML(part.name)}</span><progress value="${progressValue}" max="${totalSteps}"></progress><div class="part-progress-info"><span>${progressValue}/${totalSteps} steps</span><span>${statusText}</span></div></li>`;
            });
            partStatusList.innerHTML = items.join('');
        }

        function updateScheduleView() {
            renderPartStatusTracker();
            if (scheduleData.steps.length === 0) { return; }
            outputDiv.innerHTML = ''; calculateProgress();
            const stepInfos = scheduleData.steps.map(step => {
                let completedCount = 0, startableCount = 0;
                step.partList.forEach(partInfo => { if(scheduleData.completedTasks.has(getTaskKey(partInfo.name, step.color, partInfo.index))) completedCount++; else if(isPartStartable(partInfo.name, partInfo.index)) startableCount++; });
                return { ...step, completedCount, startableCount };
            });
            const completedSteps = [], fullyReadySteps = [], partiallyReadySteps = [], waitingSteps = [];
            stepInfos.forEach(s => {
                const remaining = s.partList.length - s.completedCount;
                if (remaining === 0) completedSteps.push(s); else if (s.startableCount === remaining) fullyReadySteps.push(s); else if (s.startableCount > 0) partiallyReadySteps.push(s); else waitingSteps.push(s);
            });
            const mergedReadyGroups = new Map();
            fullyReadySteps.forEach(s => { if(!mergedReadyGroups.has(s.color)) mergedReadyGroups.set(s.color, []); mergedReadyGroups.get(s.color).push(s); });
            outputDiv.innerHTML = '';
            completedSteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
            mergedReadyGroups.forEach(group => outputDiv.appendChild(createMergedStepWrapper(group)));
            partiallyReadySteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
            waitingSteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
        }
        
        function calculateProgress() {
            const { partToSequence, completedTasks } = scheduleData;
            if (!partToSequence || partToSequence.size === 0) { progressPercentageEl.textContent = 'Progress: 0%'; return;}
            let completedPartsCount = 0;
            partToSequence.forEach((sequence, partName) => { if (sequence.every((color, index) => completedTasks.has(getTaskKey(partName, color, index)))) completedPartsCount++; });
            const percentage = Math.round((completedPartsCount / partToSequence.size) * 100);
            progressPercentageEl.textContent = `Progress: ${percentage}%`;
        }

        function handleOutputChange(e) {
            const target = e.target;
            const toggleTask = (partName, color, index, shouldBeChecked) => { const key = getTaskKey(partName, color, index); if (shouldBeChecked) scheduleData.completedTasks.add(key); else scheduleData.completedTasks.delete(key); };
            if (target.matches('.part-checkbox')) { toggleTask(target.dataset.partName, target.dataset.color, parseInt(target.dataset.index), target.checked); }
            else if (target.matches('.master-checkbox')) {
                const isChecking = target.checked;
                const stepIds = (target.dataset.originalStepIds || target.dataset.stepId).split(',').map(Number);
                stepIds.forEach(stepId => {
                    const step = scheduleData.steps.find(s => s.id === stepId); if (!step) return;
                    step.partList.forEach(({name, index}) => { if (!scheduleData.completedTasks.has(getTaskKey(name, step.color, index)) && isPartStartable(name, index)) toggleTask(name, step.color, index, isChecking); });
                });
            } else { return; }
            saveProgressToLocalStorage(); updateScheduleView();
        }

        function setupTooltip() {
            document.body.addEventListener('mouseover', e => {
                if (e.target.matches('.help-icon')) {
                    globalHelpTooltip.innerHTML = e.target.dataset.helpText;
                    const iconRect = e.target.getBoundingClientRect();
                    globalHelpTooltip.style.visibility = 'hidden'; globalHelpTooltip.style.display = 'block';
                    const tipRect = globalHelpTooltip.getBoundingClientRect();
                    globalHelpTooltip.style.display = ''; let top = iconRect.top - tipRect.height - 10, left = iconRect.left + (iconRect.width / 2) - (tipRect.width / 2);
                    if (top < 10) top = iconRect.bottom + 10;
                    if (left < 10) left = 10;
                    if (left + tipRect.width > window.innerWidth - 10) left = window.innerWidth - tipRect.width - 10;
                    globalHelpTooltip.style.top = `${top + window.scrollY}px`; globalHelpTooltip.style.left = `${left + window.scrollX}px`;
                    globalHelpTooltip.style.visibility = 'visible'; globalHelpTooltip.style.opacity = '1';
                }
            });
            document.body.addEventListener('mouseout', e => { if (e.target.matches('.help-icon')) { globalHelpTooltip.style.opacity = '0'; globalHelpTooltip.style.visibility = 'hidden'; } });
        }
        
        function autoSaveProjectState() { if (!state.projectId) return; try { localStorage.setItem(`paintSequencerProject_${state.projectId}`, JSON.stringify(state)); } catch (e) { console.error("Could not auto-save state:", e); } }
        function saveProgressToLocalStorage() { if (!state.projectId) return; try { localStorage.setItem(`paintSequencerProgress_${state.projectId}`, JSON.stringify(Array.from(scheduleData.completedTasks))); } catch (e) { console.error("Could not save progress:", e); } }
        function clearAutoSavedProjectState() { if (!state.projectId) return; localStorage.removeItem(`paintSequencerProject_${state.projectId}`); }
        
        function showFeedback(element, message, isError = false) {
            element.textContent = message;
            element.style.color = isError ? 'var(--danger-color)' : 'var(--secondary-color)';
            element.style.opacity = '1';
            setTimeout(() => { element.style.opacity = '0'; }, 3000);
        }

        function shareViaURL() {
            const base64 = btoa(unescape(encodeURIComponent(JSON.stringify(state))));
            window.location.hash = base64;
            navigator.clipboard.writeText(window.location.href).then(() => {
                showFeedback(document.getElementById('share-feedback'), 'Shareable link copied to clipboard!');
            });
            clearAutoSavedProjectState(); markAsSaved();
        }
        
        function updateFileInfoDisplay(handle) { if (handle) { fileInfoDisplay.innerHTML = `Current File: <strong>${sanitizeHTML(handle.name)}</strong>`; } else { fileInfoDisplay.innerHTML = `No file loaded. Save to create one.`; } }
        
        async function handleLoadFile() {
            try {
                const [handle] = await window.showOpenFilePicker({ types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }] });
                fileHandle = handle;
                const file = await fileHandle.getFile();
                const content = await file.text();
                const data = JSON.parse(content);
                loadProjectFromData(data, false);
                updateFileInfoDisplay(fileHandle);
            } catch (err) { if (err.name !== 'AbortError') console.error('Error loading file:', err); }
        }

        async function handleSaveFile() {
            try {
                if (!fileHandle) {
                    fileHandle = await window.showSaveFilePicker({ suggestedName: 'paint-project.json', types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }] });
                    updateFileInfoDisplay(fileHandle);
                }
                const writable = await fileHandle.createWritable();
                await writable.write(generateProjectJSON());
                await writable.close();
                markAsSaved(); showFeedback(fileOpFeedback, "File saved successfully!");
            } catch (err) { if (err.name !== 'AbortError') { console.error('Error saving file:', err); showFeedback(fileOpFeedback, "Error saving file.", true); } }
        }

        function decodeStateFromURL() {
            if (!window.location.hash) return null;
            try {
                let loadedState = JSON.parse(decodeURIComponent(escape(atob(window.location.hash.substring(1)))));
                if (loadedState && loadedState.paints && loadedState.parts) {
                    if (!loadedState.projectId) loadedState.projectId = generateId();
                    if (loadedState.parts.length > 0 && loadedState.parts[0].sequence.length > 0 && typeof loadedState.parts[0].sequence[0] === 'string') {
                        const map = new Map(loadedState.paints.map(p => [p.name, p.id]));
                        loadedState.parts.forEach(part => { part.sequence = part.sequence.map(name => map.get(name)).filter(id => id !== undefined); });
                    }
                    return loadedState;
                }
            } catch (e) { console.error("Failed to load state from URL hash:", e); }
            return null;
        }
        
        function loadAutoSavedProjectState(projectId) {
            if (!projectId) return null;
            const savedData= localStorage.getItem(`paintSequencerProject_${projectId}`);
            if (savedData) { try { return JSON.parse(savedData); } catch (e) { console.error("Failed to parse auto-saved state:", e); return null; } }
            return null;
        }
        
        function loadProgressFromLocalStorage(projectId) {
            scheduleData.completedTasks.clear();
            if (!projectId) return;
            const savedData = localStorage.getItem(`paintSequencerProgress_${projectId}`);
            if (savedData) { try { scheduleData.completedTasks = new Set(JSON.parse(savedData)); } catch(e) { console.error("Failed to parse progress:", e); } }
        }
        
        function handleRevert() { if (confirm("Discard all unsaved changes and revert to the last saved version of this project?")) { clearAutoSavedProjectState(); window.location.reload(); } }
        function handleResetProgress() { if (confirm("Are you sure you want to reset all progress for this project? All checkboxes will be cleared.")) { scheduleData.completedTasks.clear(); saveProgressToLocalStorage(); updateScheduleView(); } }
        
        function _resetSchedule(clearProgress = true) {
            scheduleData.steps = []; scheduleData.partToSequence.clear(); scheduleData.currentTargetPartName = null; scheduleData.targetPathStepIds.clear();
            if (clearProgress && state.projectId) { scheduleData.completedTasks.clear(); saveProgressToLocalStorage(); }
            outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">Your schedule will appear here.</p>'; progressPercentageEl.textContent = ''; targetPartSelect.innerHTML = '';
            outputSection.classList.remove('invalidated');
            document.getElementById('part-status-list').innerHTML = `<li style="color: var(--text-secondary-color);">Generate a schedule to see part status.</li>`;
        }
        
        function _performReset(isNewProject = true) {
            if(state.projectId) { localStorage.removeItem(`paintSequencerProgress_${state.projectId}`); localStorage.removeItem(`paintSequencerProject_${state.projectId}`); }
            state = { projectId: generateId(), title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } };
            nextPartId = 0; nextPaintId = 0; _resetSchedule(true);
            if(isNewProject) { isPristineState = true; container.classList.add('is-welcome'); history.pushState("", document.title, window.location.pathname + window.location.search); fileHandle = null; updateFileInfoDisplay(null); }
            exitStampMode(); markAsSaved();
        }
        
        function handleReset() { if (confirm('Reset everything? This will clear all data, including auto-saves and progress for this project.')) { _performReset(); renderAll(); } }
        
        const projectSchema = { "$schema": "http://json-schema.org/draft-07/schema#", "title": "Paint Sequencer Project", "description": "A project file for the Paint Sequencer application.", "type": "object", "properties": { "title": { "type": "string" }, "paints": { "type": "array", "items": { "type": "object", "properties": { "id": { "type": "number" }, "name": { "type": "string" } }, "required": ["id", "name"] } }, "parts": { "type": "array", "items": { "type": "object", "properties": { "id": { "type": "number" }, "name": { "type": "string" }, "sequence": { "type": "array", "items": { "type": "number" } } }, "required": ["id", "name", "sequence"] } } }, "required": ["title", "paints", "parts"] };
        function generateProjectJSON() { return JSON.stringify({ title: state.title, paints: state.paints.map(({ id, name }) => ({ id, name })), parts: state.parts.map(({ id, name, sequence }) => ({ id, name, sequence })) }, null, 2); }
        function openJsonModal() { document.getElementById('json-export-area').value = generateProjectJSON(); document.getElementById('json-schema-area').textContent = JSON.stringify(projectSchema, null, 2); document.getElementById('json-modal-overlay').style.display = 'block'; }
        function closeJsonModal() { document.getElementById('json-modal-overlay').style.display = 'none'; resetJsonImportStatus(); }
        function setJsonImportStatus(message, isError=false){ const el = document.getElementById('json-status'); el.textContent = message; el.className = isError ? 'error' : 'success'; }
        function resetJsonImportStatus(){ setJsonImportStatus('', false); }
        async function handleJsonImport() {
            resetJsonImportStatus();
            const jsonText = document.getElementById('json-import-area').value, jsonUrl = document.getElementById('json-import-url').value; let projectData;
            try {
                if (jsonText) { projectData = JSON.parse(jsonText); } 
                else if (jsonUrl) { setJsonImportStatus("Fetching from URL..."); const response = await fetch(jsonUrl); if (!response.ok) throw new Error(`Failed to fetch: ${response.statusText}`); projectData = await response.json(); } 
                else { setJsonImportStatus("Please paste JSON or provide a URL.", true); return; }
                if (!projectData.title || !Array.isArray(projectData.paints) || !Array.isArray(projectData.parts)) { throw new Error("Invalid JSON structure. Missing required fields."); }
                if(confirm("This will replace your current project. All unsaved changes and progress will be lost. Continue?")) { loadProjectFromData(projectData); closeJsonModal(); }
            } catch (error) { console.error("JSON Import Error:", error); setJsonImportStatus(`Error: ${error.message}`, true); }
        }
        function setupJsonModal() {
            importExportBtn.addEventListener('click', openJsonModal); const modal = document.getElementById('json-modal');
            document.getElementById('json-modal-close-btn').addEventListener('click', closeJsonModal); document.getElementById('json-modal-overlay').addEventListener('click', e => { if (e.target === document.getElementById('json-modal-overlay')) closeJsonModal(); });
            const tabs = modal.querySelectorAll('.modal-tab'), panes = modal.querySelectorAll('.tab-pane');
            tabs.forEach(tab => tab.addEventListener('click', () => { tabs.forEach(t => t.classList.remove('active')); panes.forEach(p => p.classList.remove('active')); tab.classList.add('active'); document.getElementById(`tab-${tab.dataset.tab}`).classList.add('active'); }));
            document.getElementById('copy-json-btn').addEventListener('click', () => navigator.clipboard.writeText(document.getElementById('json-export-area').value).then(() => alert('JSON copied to clipboard!')));
            document.getElementById('import-json-btn').addEventListener('click', handleJsonImport);
        }
        function loadProjectFromData(data, clearFileHandle = true) {
            _performReset(false); state.title = data.title; state.paints = data.paints; state.parts = data.parts;
            if (clearFileHandle) { fileHandle = null; }
            dismissWelcome(); markAsSaved(); initializeAppLogic(); updateFileInfoDisplay(fileHandle);
        }

        function loadExampleProject() {
            dismissWelcome();
            state.title = 'HG Gundam "Paint-by-Numbers"';
            state.paints = [ {id: 0, name: 'Primer'}, {id: 1, name: 'Frame Gray'}, {id: 2, name: 'Armor White'}, {id: 3, name: 'Gundam Blue'}, {id: 4, name: 'Fin Red'}, {id: 5, name: 'V-Fin Yellow'}, {id: 6, name: 'Gloss Clearcoat'} ];
            state.parts.push( { id: 0, name: 'A-13 (Chest)', sequence: [0, 3, 2, 6] }, { id: 1, name: 'B-10 (Skirt)', sequence: [0, 2, 0, 3, 6]}, { id: 2, name: 'C-2, C-5 (Leg Frame)', sequence: [1] }, { id: 3, name: 'D-1 (Shield)', sequence: [0, 4, 2, 6] }, { id: 4, name: 'B-9 (V-Fin)', sequence: [0, 5, 6] } );
            markAsUnsavedAndAutoSave();
            initializeAppLogic();
        }
        
        function initializeAppLogic() { nextPartId = state.parts.reduce((max, p) => Math.max(max, p.id), -1) + 1; nextPaintId = state.paints.reduce((max, p) => Math.max(max, p.id), -1) + 1; loadProgressFromLocalStorage(state.projectId); renderAll(); generateOptimalOrder(); }
        function initializeApp() {
            const getDefaultState = () => ({ projectId: generateId(), title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } });
            let loadedState = null, stateFromURL = decodeStateFromURL();
            if (stateFromURL) { let autoSavedState = loadAutoSavedProjectState(stateFromURL.projectId); loadedState = autoSavedState || stateFromURL; if(autoSavedState) markAsUnsavedAndAutoSave(); else markAsSaved(); }
            if (loadedState) { state = { ...getDefaultState(), ...loadedState }; isPristineState = false; } else { _performReset(true); }
            if(isPristineState) container.classList.add('is-welcome');
            initializeAppLogic(); updateFileInfoDisplay(null);
            if (!isFSSupported) { [loadFileBtn, saveFileBtn, document.getElementById('load-file-welcome-btn')].forEach(btn => { if(btn) { btn.disabled = true; btn.title = "Your browser does not support the File System Access API."; } }); }
        }
        
        const eventListeners = [ { el: document, event: 'click', handler: (e) => { if (!paintSelectPopup.contains(e.target) && !e.target.matches('.add-paint-target')) closePaintSelectPopup(); } }, { el: paintSelectPopup, event: 'click', handler: handlePaintSelect }, { el: partSequenceContainer, event: 'click', handler: handleSequenceInteraction }, { el: document.getElementById('add-paint-btn'), event: 'click', handler: handleAddPaint }, { el: document.getElementById('paint-input'), event: 'keydown', handler: e => e.key === 'Enter' && handleAddPaint() }, { el: paintList, event: 'click', handler: handlePaintListClick }, { el: paintList, event: 'blur', handler: (e) => handleNameEdit(e, 'paint'), capture: true }, { el: paintList, event: 'keydown', handler: (e) => handleNameEdit(e, 'paint') }, { el: document.getElementById('add-part-btn'), event: 'click', handler: handleAddPart }, { el: document.getElementById('part-input'), event: 'keydown', handler: e => e.key === 'Enter' && handleAddPart() }, { el: partList, event: 'click', handler: handlePartListClick }, { el: partList, event: 'blur', handler: (e) => handleNameEdit(e, 'part'), capture: true }, { el: partList, event: 'keydown', handler: (e) => handleNameEdit(e, 'part') }, { el: titleInput, event: 'input', handler: handleTitleChange }, { el: shareBtn, event: 'click', handler: shareViaURL }, { el: revertBtn, event: 'click', handler: handleRevert }, { el: generateBtn, event: 'click', handler: generateOptimalOrder }, { el: resetProgressBtn, event: 'click', handler: handleResetProgress }, { el: resetBtn, event: 'click', handler: handleReset }, { el: stampToolBtn, event: 'click', handler: enterStampMode }, { el: document.getElementById('exit-stamp-btn'), event: 'click', handler: exitStampMode }, { el: document.getElementById('stamp-color-select'), event: 'change', handler: handleStampColorChange }, { el: outputDiv, event: 'change', handler: handleOutputChange }, { el: targetPartSelect, event: 'change', handler: () => { scheduleData.currentTargetPartName = targetPartSelect.value || null; updateTargetPath(); updateScheduleView(); }}, { el: loadFileBtn, event: 'click', handler: handleLoadFile }, { el: saveFileBtn, event: 'click', handler: handleSaveFile }, { el: document.getElementById('load-example-btn'), event: 'click', handler: loadExampleProject }, { el: document.getElementById('start-blank-btn'), event: 'click', handler: dismissWelcome }, { el: document.getElementById('load-file-welcome-btn'), event: 'click', handler: handleLoadFile }, { el: document.getElementById('import-json-welcome-btn'), event: 'click', handler: openJsonModal } ];
        eventListeners.forEach(({el, event, handler, capture}) => el && el.addEventListener(event, handler, capture || false));
        
        setupJsonModal();
        setupTooltip();
        initializeApp();
    });
    </script>
</body>
</html>
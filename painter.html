<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Sequencer</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #1c1e21;
            --text-secondary-color: #606770;
            --primary-color: #1877f2;
            --primary-hover-color: #166fe5;
            --secondary-color: #42b72a;
            --secondary-hover-color: #36a420;
            --danger-color: #fa383e;
            --border-color: #dddfe2;
            --stamp-color: #ffc107;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        body { font-family: var(--font-family); line-height: 1.6; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 24px; }
        .container { max-width: 1200px; margin: 0 auto; display: flex; flex-direction: column; gap: 24px; }
        .card { background-color: var(--surface-color); box-shadow: var(--shadow); border-radius: 8px; padding: 20px; position: relative; }
        .card-header { display: flex; justify-content: space-between; align-items: baseline; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px; }
        .card-header h2 { border: none; padding: 0; margin: 0; }
        .card-header .legend { color: var(--text-secondary-color); font-size: 0.9em; white-space: nowrap; }
        #progress-percentage { font-weight: 600; color: var(--primary-color); margin-left: auto; padding-right: 20px; }
        h1 { font-size: 1.8rem; margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px;}
        .title-input { font-size: 1.2rem; font-weight: 600; border: none; border-bottom: 2px solid transparent; width: 100%; padding: 4px; margin-bottom: 20px; transition: border-color 0.2s; }
        .title-input:focus { outline: none; border-bottom-color: var(--primary-color); }
        .setup-container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
        .input-group { display: flex; gap: 8px; margin-bottom: 15px; }
        .input-group input { flex-grow: 1; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 1rem; }
        .input-group button { white-space: nowrap; }
        button { padding: 10px 18px; background-color: var(--primary-color); color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: background-color 0.2s, opacity 0.2s; }
        button:hover { background-color: var(--primary-hover-color); }
        .btn-add, .btn-save.unsaved { background-color: var(--secondary-color); }
        .btn-add:hover, .btn-save.unsaved:hover { background-color: var(--secondary-hover-color); }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: #e03238; }
        .btn-stamp { background-color: var(--stamp-color); color: var(--text-color); }
        .btn-stamp:hover { background-color: #e0ac00; }
        .item-list { list-style-type: none; padding: 0; display: flex; flex-wrap: wrap; gap: 10px; }
        .item-list li { display: flex; align-items: center; background-color: var(--bg-color); border-radius: 15px; padding: 5px 5px 5px 12px; font-size: 0.9rem; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .editable-name { cursor: text; padding: 2px 4px; border-radius: 3px; }
        .editable-name[contenteditable]:focus { outline: 2px solid var(--primary-color); background-color: #eaf3ff; }
        .remove-btn { background: #ccc; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; line-height: 20px; text-align: center; cursor: pointer; margin-left: 8px; font-weight: bold; transition: background-color 0.2s; }
        .remove-btn:hover { background-color: #a0a0a0; }
        .part-sequence-row { display: flex; align-items: center; gap: 15px; padding: 12px 0; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        .part-sequence-row:last-child { border-bottom: none; }
        .part-name-label { font-weight: 600; width: 150px; flex-shrink: 0; }
        .sequence-steps { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; flex-grow: 1; }
        .paint-step { display: flex; align-items: center; gap: 6px; background: #e4e6eb; border-radius: 6px; padding: 4px; position: relative; }
        .reorder-btn { display: inline-flex; align-items: center; justify-content: center; background: none; border: 1px solid #ccc; color: #888; border-radius: 50%; width: 22px; height: 22px; padding: 0; font-size: 14px; line-height: 1; text-align: center; cursor: pointer; transition: all 0.2s; }
        .reorder-btn:hover { background-color: #ddd; border-color: #aaa; color: #333; }
        .paint-step .remove-step-btn { color: #aaa; cursor: pointer; font-weight: bold; padding: 0 4px; }
        .paint-step .remove-step-btn:hover { color: var(--danger-color); }
        .add-paint-control select, #stamp-color-select { padding: 6px; border-radius: 6px; border: 1px solid var(--border-color); }
        .add-paint-control button { font-size: 0.9rem; padding: 6px 12px; }
        #output { border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; background: #f8f9fa; min-height: 100px; transition: opacity 0.3s; }
        .output-step-container { display: flex; align-items: center; transition: opacity 0.3s; }
        .output-step-container .step-checkbox { margin-right: 15px; transform: scale(1.5); cursor: pointer; }
        .output-step { display: flex; align-items: center; gap: 10px; padding: 10px 10px 5px 10px; flex-grow: 1; }
        .completion-notice { color: var(--text-secondary-color); font-size: 0.9em; padding: 0px 10px 10px 48px; border-bottom: 1px dotted var(--border-color); }
        .output-wrapper:last-child .completion-notice, .output-wrapper:last-child .output-step { border-bottom: none; }
        .output-icon { font-size: 1.5rem; line-height: 1; }
        .start-indicator { cursor: help; font-size: 1.5rem; line-height: 1; }
        .output-wrapper.is-completed { opacity: 0.5; text-decoration: line-through; }
        .output-wrapper.is-waiting { opacity: 0.6; }
        .output-wrapper.is-waiting .output-step-container { cursor: not-allowed; }
        .output-action { font-weight: 600; min-width: 220px;}
        .output-color-name { background: #eee; padding: 2px 8px; border-radius: 4px; font-family: monospace; }
        #output-section.invalidated #output { opacity: 0.4; }
        #output-section.invalidated::after { content: 'Schedule outdated. Please regenerate.'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(255, 255, 100, 0.85); border: 1px solid #e0e060; padding: 10px 20px; border-radius: 6px; font-weight: 600; text-align: center; }
        .main-controls { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 20px; }
        #save-feedback { color: var(--secondary-color); font-weight: 600; opacity: 0; transition: opacity 0.3s; }
        #stamp-tool-toolbar { display: none; background-color: var(--bg-color); padding: 15px; border-radius: 6px; margin-bottom: 20px; align-items: center; gap: 15px; border: 1px solid var(--border-color); }
        .stamp-mode-active #stamp-tool-toolbar { display: flex; }
        .stamp-mode-active .add-paint-control, .stamp-mode-active .reorder-btn, .stamp-mode-active .remove-step-btn { display: none; }
        .drop-target { border: 2px dashed var(--border-color); border-radius: 6px; cursor: pointer; transition: all 0.2s; position: relative; }
        .drop-target:hover { border-color: var(--stamp-color); background-color: #fff8e1; }
        .drop-target::before { content: '+'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; color: #ccc; transition: color 0.2s; }
        .drop-target:hover::before { color: var(--stamp-color); }
        .drop-target.large { width: 50px; height: 32px; }
        .drop-target.small { width: 20px; height: 32px; }
        
        @media (max-width: 900px) {
            .setup-container { grid-template-columns: 1fr; }
            .part-sequence-row { flex-direction: column; align-items: flex-start; }
            .main-controls { flex-direction: column; }
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="card">
            <h1>🎨 Paint Sequencer</h1>
            <input type="text" id="title-input" class="title-input" placeholder="Enter Project Title">
        </div>

        <div class="card">
            <div class="setup-container">
                <div id="paint-management">
                    <div class="card-header"><h2>Available Paints</h2></div>
                    <div class="input-group">
                        <input type="text" id="paint-input" placeholder="Add paints, comma-separated">
                        <button id="add-paint-btn" class="btn-add">Add</button>
                    </div>
                    <ul id="paint-list" class="item-list"></ul>
                </div>
                <div id="part-management">
                    <div class="card-header"><h2>📦 Parts to be Painted</h2></div>
                    <div class="input-group">
                        <input type="text" id="part-input" placeholder="Add parts, comma-separated">
                        <button id="add-part-btn" class="btn-add">Add</button>
                    </div>
                    <ul id="part-list" class="item-list"></ul>
                </div>
            </div>
        </div>

        <div class="card" id="sequence-card">
            <div class="card-header">
                <h2>Assign Paint Sequence</h2>
                <button id="stamp-tool-btn" class="btn-stamp">🖌️ Stamp Tool</button>
            </div>
            <div id="stamp-tool-toolbar">
                <strong>Stamping with:</strong>
                <select id="stamp-color-select"></select>
                <button id="exit-stamp-btn" class="btn-danger">Finish Stamping</button>
            </div>
            <div id="part-sequence-container"><p style="color: var(--text-secondary-color);">Add parts to begin.</p></div>
        </div>
        
        <div class="card">
            <div class="main-controls">
                <button id="save-btn" class="btn-save">💾 Save & Copy Link</button>
                <button id="generate-btn">✨ Generate Optimal Order</button>
                <button id="reset-btn" class="btn-danger">🔄 Reset All</button>
            </div>
            <p style="text-align: center; margin: 10px 0 0 0;"><span id="save-feedback"></span></p>
        </div>

        <div class="card" id="output-section">
            <div class="card-header">
                <h2>✔️ Optimized Schedule</h2>
                <span id="progress-percentage"></span>
                <small class="legend">⭐ = Ready to start!</small>
            </div>
            <div id="output"><p style="color: var(--text-secondary-color);">Your schedule will appear here.</p></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let state = { title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } };
        let nextPartId = 0;
        let scheduleData = { steps: [], completedStepIds: new Set(), partNameToStepIds: new Map() };

        const stampToolBtn = document.getElementById('stamp-tool-btn');
        const stampToolToolbar = document.getElementById('stamp-tool-toolbar');
        const stampColorSelect = document.getElementById('stamp-color-select');
        const exitStampBtn = document.getElementById('exit-stamp-btn');
        const titleInput = document.getElementById('title-input');
        const saveBtn = document.getElementById('save-btn');
        const paintInput = document.getElementById('paint-input');
        const addPaintBtn = document.getElementById('add-paint-btn');
        const paintList = document.getElementById('paint-list');
        const partInput = document.getElementById('part-input');
        const addPartBtn = document.getElementById('add-part-btn');
        const partList = document.getElementById('part-list');
        const partSequenceContainer = document.getElementById('part-sequence-container');
        const generateBtn = document.getElementById('generate-btn');
        const resetBtn = document.getElementById('reset-btn');
        const outputSection = document.getElementById('output-section');
        const outputDiv = document.getElementById('output');
        const progressPercentageEl = document.getElementById('progress-percentage');
        
        const sanitizeHTML = str => str.replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[match]);

        const renderAll = () => { renderTitle(); renderPaintList(); renderPartList(); renderSequenceBuilder(); };
        const renderTitle = () => { titleInput.value = state.title; };
        
        const renderPaintList = () => {
             paintList.innerHTML = state.paints.map(p => `<li><span class="editable-name" contenteditable="true" data-original-name="${sanitizeHTML(p)}">${sanitizeHTML(p)}</span><span class="remove-btn" data-paint-name="${sanitizeHTML(p)}" title="Remove Paint">×</span></li>`).join('');
        };
        const renderPartList = () => {
            partList.innerHTML = state.parts.map(p => `<li><span class="editable-name" contenteditable="true" data-part-id="${p.id}">${sanitizeHTML(p.name)}</span><span class="remove-btn" data-part-id="${p.id}" title="Remove Part">×</span></li>`).join('');
        };
        
        function renderSequenceBuilder() {
            const sequenceCard = document.getElementById('sequence-card');
            partSequenceContainer.innerHTML = '';
            if (state.parts.length === 0) {
                partSequenceContainer.innerHTML = '<p style="color: var(--text-secondary-color);">Add parts to begin.</p>'; return;
            }
            const isStamping = state.stampMode.isActive;
            sequenceCard.classList.toggle('stamp-mode-active', isStamping);
            state.parts.forEach(part => {
                const row = document.createElement('div');
                row.className = 'part-sequence-row';;
                row.dataset.partId = part.id;
                let sequenceItems = [];
                if (isStamping) {
                    sequenceItems.push(`<div class="drop-target large" data-insert-index="0"></div>`);
                    part.sequence.forEach((color, index) => {
                        sequenceItems.push(`<div class="paint-step"><span>${sanitizeHTML(color)}</span></div>`);
                        sequenceItems.push(`<div class="drop-target small" data-insert-index="${index + 1}"></div>`);
                    });
                } else {
                    sequenceItems = part.sequence.map((color, index) => `
                        <div class="paint-step">
                            <button class="reorder-btn" data-dir="left" data-index="${index}" title="Move Left">←</button>
                            <span>${sanitizeHTML(color)}</span>
                            <button class="reorder-btn" data-dir="right" data-index="${index}" title="Move Right">→</button>
                            <span class="remove-step-btn" data-index="${index}" title="Remove step">×</span>
                        </div>`);
                }
                let selectOptions = state.paints.map(p => `<option value="${sanitizeHTML(p)}">${sanitizeHTML(p)}</option>`).join('') || '<option disabled>Add paints first</option>';
                row.innerHTML = `
                    <div class="part-name-label">${sanitizeHTML(part.name)}</div>
                    <div class="sequence-steps">${sequenceItems.join('')}</div>
                    <div class="add-paint-control"><select ${state.paints.length===0?'disabled':''}>${selectOptions}</select><button class="btn-add add-step-btn" ${state.paints.length===0?'disabled':''}>Add</button></div>`;
                partSequenceContainer.appendChild(row);
            });
        }
        
        function markAsUnsaved() { document.getElementById('save-btn').classList.add('unsaved'); }
        function invalidateSchedule() { if (scheduleData.steps.length > 0) outputSection.classList.add('invalidated'); }

        function enterStampMode() {
            if (state.paints.length === 0) { alert("Please add at least one paint color before using the Stamp Tool."); return; }
            state.stampMode.isActive = true;
            stampToolBtn.style.display = 'none';
            stampColorSelect.innerHTML = state.paints.map(p => `<option value="${sanitizeHTML(p)}">${sanitizeHTML(p)}</option>`).join('');
            state.stampMode.color = stampColorSelect.value;
            renderAll();
        }

        function exitStampMode() { state.stampMode.isActive = false; stampToolBtn.style.display = 'block'; renderAll(); }
        function handleStampColorChange() { state.stampMode.color = stampColorSelect.value; }
        function handleTitleChange() { state.title = titleInput.value; markAsUnsaved(); }
        
        function handleAddItems(inputEl, collection, createItem) {
            const values = inputEl.value.split(',').map(v => v.trim()).filter(Boolean);
            if (values.length === 0) return;
            values.forEach(value => { 
                const exists = collection.some(item => (item.name || item) === value);
                if (!exists) collection.push(createItem(value));
            });
            inputEl.value = ''; invalidateSchedule(); markAsUnsaved(); renderAll();
        }

        function handleAddPaint() { handleAddItems(paintInput, state.paints, value => value); }
        function handleAddPart() { handleAddItems(partInput, state.parts, value => ({ id: nextPartId++, name: value, sequence: [] })); }
        
        function handlePaintListClick(e) {
            if (!e.target.matches('.remove-btn')) return;
            const paintName = e.target.dataset.paintName;
            if (state.parts.some(p => p.sequence.includes(paintName))) {
                if (!confirm(`Warning: This will remove "${paintName}" from all part sequences. Proceed?`)) return;
                state.parts.forEach(part => { part.sequence = part.sequence.filter(color => color !== paintName); });
            }
            state.paints = state.paints.filter(p => p !== paintName);
            invalidateSchedule(); markAsUnsaved(); renderAll();
        }

        function handlePartListClick(e) {
            if (!e.target.matches('.remove-btn')) return;
            const partId = parseInt(e.target.dataset.partId);
            const part = state.parts.find(p => p.id === partId);
            if (part && confirm(`Remove part "${part.name}"?`)) {
                state.parts = state.parts.filter(p => p.id !== partId);
                invalidateSchedule(); markAsUnsaved(); renderAll();
            }
        }

        function handleNameEdit(e, listType) {
            const target = e.target;
            const saveEdit = () => {
                const newValue = target.textContent.trim();
                let oldValue, isDuplicate;
                
                if (listType === 'paint') {
                    oldValue = target.dataset.originalName;
                    isDuplicate = state.paints.includes(newValue);
                } else {
                    const partId = parseInt(target.dataset.partId);
                    const part = state.parts.find(p => p.id === partId);
                    if (!part) return;
                    oldValue = part.name;
                    isDuplicate = state.parts.some(p => p.name === newValue && p.id !== partId);
                }

                if (newValue === oldValue) return;
                if (!newValue) { alert("Name cannot be empty."); target.textContent = oldValue; return; }
                if (isDuplicate && newValue !== oldValue) { alert(`Name "${newValue}" already exists.`); target.textContent = oldValue; return; }
                
                if (listType === 'paint') {
                    const paintIndex = state.paints.indexOf(oldValue);
                    if (paintIndex > -1) {
                        state.paints[paintIndex] = newValue;
                        state.parts.forEach(part => {
                            part.sequence = part.sequence.map(color => color === oldValue ? newValue : color);
                        });
                    }
                } else {
                    const part = state.parts.find(p => p.id === parseInt(target.dataset.partId));
                    if (part) part.name = newValue;
                }
                invalidateSchedule(); markAsUnsaved(); renderAll();
            };

            if (e.type === 'keydown') {
                if (e.key === 'Enter') { e.preventDefault(); target.blur(); }
                if (e.key === 'Escape') {
                    target.textContent = listType === 'paint' ? target.dataset.originalName : state.parts.find(p => p.id === parseInt(target.dataset.partId))?.name;
                    target.blur();
                }
            } else if (e.type === 'blur') {
                saveEdit();
            }
        }
        
        function handleSequenceInteraction(e) {
            const partRow = e.target.closest('.part-sequence-row');
            if (!partRow) return;
            const part = state.parts.find(p => p.id === parseInt(partRow.dataset.partId));
            if (!part) return;
            if (state.stampMode.isActive && e.target.matches('.drop-target')) {
                const insertIndex = parseInt(e.target.dataset.insertIndex);
                part.sequence.splice(insertIndex, 0, state.stampMode.color);
                markAsUnsaved(); invalidateSchedule(); renderAll(); return;
            }
            let stateChanged = false;
            if (e.target.matches('.add-step-btn')) {
                const select = partRow.querySelector('select');
                if (select.value) { part.sequence.push(select.value); stateChanged = true; }
            } else if (e.target.matches('.remove-step-btn')) {
                part.sequence.splice(parseInt(e.target.dataset.index), 1); stateChanged = true;
            } else if (e.target.matches('.reorder-btn')) {
                const index = parseInt(e.target.dataset.index); const dir = e.target.dataset.dir;
                if (dir === 'left' && index > 0) { [part.sequence[index], part.sequence[index - 1]] = [part.sequence[index - 1], part.sequence[index]]; stateChanged = true; } 
                else if (dir === 'right' && index < part.sequence.length - 1) { [part.sequence[index], part.sequence[index + 1]] = [part.sequence[index + 1], part.sequence[index]]; stateChanged = true; }
            }
            if (stateChanged) { invalidateSchedule(); markAsUnsaved(); renderAll(); }
        }

        function generateOptimalOrder() {
            if (state.parts.filter(p => p.sequence.length === 0).length > 0) {
                if (!confirm(`Warning: Some parts have no paint sequence and will be ignored. Continue?`)) return;
            }
            outputSection.classList.remove('invalidated');
            scheduleData = { steps: [], completedStepIds: new Set(), partNameToStepIds: new Map() };
            
            let partsToProcess = JSON.parse(JSON.stringify(state.parts)).filter(p => p.sequence.length > 0).map(p => ({ ...p, currentStep: 0, originalSequence: p.sequence }));
            if (partsToProcess.length === 0) {
                outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">No parts with paint sequences.</p>'; return;
            }
            
            const partColorToStepIndex = new Map();
            let stepIdCounter = 0;
            while (partsToProcess.some(p => p.currentStep < p.sequence.length)) {
                const readyPartsByColor = new Map();
                partsToProcess.filter(p=>p.currentStep < p.sequence.length).forEach(part => {
                    const nextColor = part.sequence[part.currentStep];
                    if (!readyPartsByColor.has(nextColor)) readyPartsByColor.set(nextColor, []);
                    readyPartsByColor.get(nextColor).push(part);
                });
                
                let priorityChoices = [], lastStepChoices = [];
                for (const [color, partList] of readyPartsByColor.entries()) {
                    (partList.some(p => p.currentStep < p.sequence.length - 1) ? priorityChoices : lastStepChoices).push({ color, partList, count: partList.length });
                }
                const choices = priorityChoices.length > 0 ? priorityChoices : lastStepChoices;
                choices.sort((a, b) => b.count - a.count);
                if (choices.length === 0) break;
                
                const bestChoice = choices[0];
                const stepId = stepIdCounter++;
                scheduleData.steps.push({
                    id: stepId, color: bestChoice.color, partList: bestChoice.partList.map(p => p.name),
                    completedParts: bestChoice.partList.filter(p => p.currentStep + 1 === p.sequence.length).map(p => p.name), dependencies: new Set()
                });
                bestChoice.partList.forEach(part => { partColorToStepIndex.set(`${part.id}_${part.sequence[part.currentStep]}`, stepId); part.currentStep++; });
            }
            partsToProcess.forEach(part => {
                for(let i = 1; i < part.originalSequence.length; i++) {
                    const prevStepId = partColorToStepIndex.get(`${part.id}_${part.originalSequence[i-1]}`);
                    const currentStepId = partColorToStepIndex.get(`${part.id}_${part.originalSequence[i]}`);
                    if(prevStepId !== undefined && currentStepId !== undefined) scheduleData.steps[currentStepId].dependencies.add(prevStepId);
                }
            });
            scheduleData.steps.forEach(step => {
                step.dependencies = Array.from(step.dependencies);
                step.partList.forEach(partName => {
                    if (!scheduleData.partNameToStepIds.has(partName)) scheduleData.partNameToStepIds.set(partName, []);
                    scheduleData.partNameToStepIds.get(partName).push(step.id);
                });
            });
            updateDynamicScheduleView();
        }
        
        function createStepElement(item, isStartable, isCompleted, isWaiting) {
            const wrapper = document.createElement('div');
            wrapper.className = 'output-wrapper';
            if(isCompleted) wrapper.classList.add('is-completed');
            if(isWaiting) wrapper.classList.add('is-waiting');
            
            const container = document.createElement('div');
            container.className = 'output-step-container';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'step-checkbox';
            checkbox.checked = isCompleted;
            
            if (item.isMerged) checkbox.dataset.originalStepIds = item.originalStepIds.join(',');
            else checkbox.dataset.stepId = item.id;
            
            const partCount = item.partList.length;
            const partLabel = partCount === 1 ? 'part' : 'parts';

            const stepDiv = document.createElement('div');
            stepDiv.className = 'output-step';
            stepDiv.innerHTML = `
                ${isStartable ? '<span class="start-indicator" title="Ready to start!">⭐</span>' : ''}
                <span class="output-icon">🎨</span>
                <span class="output-action">Load <code class="output-color-name">${sanitizeHTML(item.color)}</code></span>
                <span class="output-icon">➡️</span>
                <span>Paint (${partCount} ${partLabel}): <strong>${item.partList.map(sanitizeHTML).sort().join(', ')}</strong></span>`;
            
            container.appendChild(checkbox); container.appendChild(stepDiv);
            wrapper.appendChild(container);

            if (item.completedParts && item.completedParts.length > 0) {
                const notice = document.createElement('div');
                notice.className = 'completion-notice';
                notice.innerHTML = `✔️ Painting complete for: <strong>${item.completedParts.map(sanitizeHTML).sort().join(', ')}</strong>`;
                wrapper.appendChild(notice);
            } else {
                container.style.borderBottom = '1px dotted var(--border-color)';
            }
            return wrapper;
        }
        
        function updateDynamicScheduleView() {
            outputDiv.innerHTML = '';
            calculateProgress();
            const { completed, ready, waiting } = getTaskLists();
            
            const mergedReadySteps = new Map();
            ready.forEach(step => {
                if (!mergedReadySteps.has(step.color)) {
                    mergedReadySteps.set(step.color, { color: step.color, partList: [], completedParts: [], originalStepIds: [], isMerged: true });
                }
                const group = mergedReadySteps.get(step.color);
                group.partList.push(...step.partList);
                group.completedParts.push(...step.completedParts);
                group.originalStepIds.push(step.id);
            });
            
            completed.forEach(step => outputDiv.appendChild(createStepElement(step, false, true, false)));
            mergedReadySteps.forEach(mergedStep => outputDiv.appendChild(createStepElement(mergedStep, true, false, false)));
            waiting.forEach(step => outputDiv.appendChild(createStepElement(step, false, false, true)));
        }
        
        function getTaskLists() {
            const completed = [], ready = [], waiting = [];
            scheduleData.steps.forEach(step => {
                if (scheduleData.completedStepIds.has(step.id)) {
                    completed.push(step);
                } else {
                    const depsMet = step.dependencies.every(depId => scheduleData.completedStepIds.has(depId));
                    if(depsMet) ready.push(step); else waiting.push(step);
                }
            });
            return { completed, ready, waiting };
        }

        function calculateProgress() {
            const { partNameToStepIds, completedStepIds } = scheduleData;
            if (partNameToStepIds.size === 0) {
                progressPercentageEl.textContent = ''; return;
            }
            let completedPartsCount = 0;
            partNameToStepIds.forEach((stepIds, partName) => {
                if (stepIds.every(id => completedStepIds.has(id))) {
                    completedPartsCount++;
                }
            });
            const percentage = Math.round((completedPartsCount / partNameToStepIds.size) * 100);
            progressPercentageEl.textContent = `Progress: ${percentage}%`;
        }

        function handleCheckboxChange(e) {
            const checkbox = e.target;
            if (!checkbox.matches('.step-checkbox')) return;
            
            const wrapper = checkbox.closest('.output-wrapper');
            if (wrapper.classList.contains('is-waiting') && checkbox.checked) {
                if (!confirm("This step is not ready yet because its prerequisites are not complete.\n\nAre you sure you want to mark it as done anyway?")) {
                    e.preventDefault();
                    return;
                }
            }
            
            const originalStepIdsStr = checkbox.dataset.originalStepIds;
            if(originalStepIdsStr){
                originalStepIdsStr.split(',').forEach(idStr => scheduleData.completedStepIds.add(parseInt(idStr)));
            } else {
                const stepId = parseInt(checkbox.dataset.stepId);
                if(checkbox.checked) scheduleData.completedStepIds.add(stepId);
                else scheduleData.completedStepIds.delete(stepId);
            }
            updateDynamicScheduleView();
        }

        function saveStateToHash() {
            const stateToSave = { title: titleInput.value.trim(), paints: state.paints, parts: state.parts };
            const jsonState = JSON.stringify(stateToSave);
            const base64State = btoa(unescape(encodeURIComponent(jsonState)));
            window.location.hash = base64State;
            navigator.clipboard.writeText(window.location.href).then(() => {
                const saveFeedback = document.getElementById('save-feedback');
                saveFeedback.textContent = 'Saved! Link copied to clipboard.';
                saveFeedback.style.opacity = '1';
                setTimeout(() => { saveFeedback.style.opacity = '0'; }, 3000);
            });
            document.getElementById('save-btn').classList.remove('unsaved');
        }

        function loadStateFromHash() {
            if (!window.location.hash) return false;
            try {
                const jsonState = decodeURIComponent(escape(atob(window.location.hash.substring(1))));
                const loadedState = JSON.parse(jsonState);
                if (loadedState && loadedState.paints && loadedState.parts) {
                    state = { ...loadedState, stampMode: { isActive: false, color: null } };
                    nextPartId = state.parts.reduce((max, p) => Math.max(max, p.id), -1) + 1;
                    return true;
                }
            } catch (e) {
                console.error("Failed to load state from hash:", e);
                alert("Could not load project. The link may be corrupted.");
            }
            return false;
        }

        function _performReset() {
            state = { title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } };
            nextPartId = 0;
            scheduleData = { steps: [], completedStepIds: new Set(), partNameToStepIds: new Map() };
            outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">Your schedule will appear here.</p>';
            progressPercentageEl.textContent = '';
            outputSection.classList.remove('invalidated');
            history.pushState("", document.title, window.location.pathname + window.location.search);
            exitStampMode();
        }

        function handleReset() { if (confirm('Reset everything? This will clear all data.')) { _performReset(); renderAll(); } }
        
        function loadInitialData() {
            _performReset();
            state.title = 'Example Gundam Model';
            state.paints.push('primer', 'internal-frame-grey', 'white', 'blue', 'red', 'yellow', 'clearcoat');
            state.parts.push(
                { id: nextPartId++, name: 'A-13 (Chest)', sequence: ['primer', 'blue', 'white', 'clearcoat'] },
                { id: nextPartId++, name: 'B-4 (Skirt)', sequence: ['primer', 'blue', 'clearcoat']},
                { id: nextPartId++, name: 'C-2 (Leg Frame)', sequence: ['internal-frame-grey'] },
                { id: nextPartId++, name: 'F-9 (V-Fin)', sequence: ['primer', 'yellow', 'clearcoat'] }
            );
            renderAll();
            markAsUnsaved();
        }

        // EVENT LISTENERS
        addPaintBtn.addEventListener('click', handleAddPaint);
        paintInput.addEventListener('keydown', e => e.key === 'Enter' && handleAddPaint());
        paintList.addEventListener('click', handlePaintListClick);
        paintList.addEventListener('blur', (e) => handleNameEdit(e, 'paint'), true);
        paintList.addEventListener('keydown', (e) => handleNameEdit(e, 'paint'));
        addPartBtn.addEventListener('click', handleAddPart);
        partInput.addEventListener('keydown', e => e.key === 'Enter' && handleAddPart());
        partList.addEventListener('click', handlePartListClick);
        partList.addEventListener('blur', (e) => handleNameEdit(e, 'part'), true);
        partList.addEventListener('keydown', (e) => handleNameEdit(e, 'part'));
        partSequenceContainer.addEventListener('click', handleSequenceInteraction);
        titleInput.addEventListener('input', handleTitleChange);
        saveBtn.addEventListener('click', saveStateToHash);
        generateBtn.addEventListener('click', generateOptimalOrder);
        resetBtn.addEventListener('click', handleReset);
        stampToolBtn.addEventListener('click', enterStampMode);
        exitStampBtn.addEventListener('click', exitStampMode);
        stampColorSelect.addEventListener('change', handleStampColorChange);
        outputDiv.addEventListener('change', handleCheckboxChange);
        
        // INITIALIZATION
        if (!loadStateFromHash()) loadInitialData();
        else { document.title = state.title + " - Paint Sequencer"; renderAll(); }
    });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Sequencer</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #1c1e21;
            --text-secondary-color: #606770;
            --primary-color: #1877f2;
            --primary-hover-color: #166fe5;
            --secondary-color: #42b72a;
            --secondary-hover-color: #36a420;
            --danger-color: #fa383e;
            --warning-color: #ffc107;
            --warning-hover-color: #e0ac00;
            --border-color: #dddfe2;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        body { font-family: var(--font-family); line-height: 1.6; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 24px; }
        .container { max-width: 1200px; margin: 0 auto; display: flex; flex-direction: column; gap: 24px; }
        .card { background-color: var(--surface-color); box-shadow: var(--shadow); border-radius: 8px; padding: 20px; position: relative; }
        .card-header { display: flex; justify-content: space-between; align-items: baseline; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px; flex-wrap: wrap; gap: 10px; }
        .card-header h2 { border: none; padding: 0; margin: 0; }
        .card-header .legend { color: var(--text-secondary-color); font-size: 0.9em; white-space: nowrap; }
        .header-controls { display: contents; } /* Allows items to flow with flexbox */
        #progress-percentage { font-weight: 600; color: var(--primary-color); margin-left: auto; padding: 0 10px;}
        #target-part-select { padding: 4px 8px; border-radius: 6px; border: 1px solid var(--border-color); font-size: 0.9em; }
        h1 { font-size: 1.8rem; margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px;}
        .title-input { font-size: 1.2rem; font-weight: 600; border: none; border-bottom: 2px solid transparent; width: 100%; padding: 4px; margin-bottom: 20px; transition: border-color 0.2s; }
        .title-input:focus { outline: none; border-bottom-color: var(--primary-color); }
        .setup-container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
        .input-group { display: flex; gap: 8px; margin-bottom: 15px; }
        .input-group input { flex-grow: 1; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 1rem; }
        .input-group button { white-space: nowrap; }
        button { padding: 10px 18px; background-color: var(--primary-color); color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: background-color 0.2s, opacity 0.2s; }
        button:hover { background-color: var(--primary-hover-color); }
        .btn-add, .btn-save.unsaved { background-color: var(--secondary-color); }
        .btn-add:hover, .btn-save.unsaved:hover { background-color: var(--secondary-hover-color); }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: #e03238; }
        .btn-warning { background-color: var(--warning-color); color: var(--text-color); }
        .btn-warning:hover { background-color: var(--warning-hover-color); }
        .item-list { list-style-type: none; padding: 0; display: flex; flex-wrap: wrap; gap: 10px; }
        .item-list li { display: flex; align-items: center; background-color: var(--bg-color); border-radius: 15px; padding: 5px 5px 5px 12px; font-size: 0.9rem; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .editable-name { cursor: text; padding: 2px 4px; border-radius: 3px; }
        .editable-name[contenteditable]:focus { outline: 2px solid var(--primary-color); background-color: #eaf3ff; }
        .remove-btn { background: #ccc; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; line-height: 20px; text-align: center; cursor: pointer; margin-left: 8px; font-weight: bold; transition: background-color 0.2s; }
        .remove-btn:hover { background-color: #a0a0a0; }
        .part-sequence-row { display: flex; align-items: center; gap: 15px; padding: 12px 0; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        .part-sequence-row:last-child { border-bottom: none; }
        .part-name-label { font-weight: 600; width: 150px; flex-shrink: 0; }
        .sequence-steps { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; flex-grow: 1; }
        .paint-step { display: flex; align-items: center; gap: 6px; background: #e4e6eb; border-radius: 6px; padding: 4px; position: relative; }
        .reorder-btn { display: inline-flex; align-items: center; justify-content: center; background: none; border: 1px solid #ccc; color: #888; border-radius: 50%; width: 22px; height: 22px; padding: 0; font-size: 14px; line-height: 1; text-align: center; cursor: pointer; transition: all 0.2s; }
        .reorder-btn:hover { background-color: #ddd; border-color: #aaa; color: #333; }
        .paint-step .remove-step-btn { color: #aaa; cursor: pointer; font-weight: bold; padding: 0 4px; }
        .paint-step .remove-step-btn:hover { color: var(--danger-color); }
        .add-paint-control select, #stamp-color-select { padding: 6px; border-radius: 6px; border: 1px solid var(--border-color); }
        .add-paint-control button { font-size: 0.9rem; padding: 6px 12px; }
        #stamp-tool-btn { background-color: var(--warning-color); color: var(--text-color); }
        #stamp-tool-btn:hover { background-color: var(--warning-hover-color); }

        #output { border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; background: #f8f9fa; min-height: 100px; transition: opacity 0.3s; }
        .step-wrapper { padding: 10px 0; border-bottom: 1px solid var(--border-color); transition: background-color 0.3s, border 0.3s; }
        .step-wrapper:last-child { border-bottom: none; }
        .step-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .start-indicator { font-size: 1.5rem; line-height: 1; width: 24px; text-align: center; cursor: help;}
        .start-indicator.full { color: var(--warning-color); }
        .start-indicator.partial { color: var(--primary-color); }
        .start-indicator.stop { color: var(--danger-color); }
        .step-action { font-weight: 600; flex-grow: 1; }
        .check-all-label { white-space: nowrap; font-size: 0.9em; color: var(--text-secondary-color); }
        .check-all-label input { margin-right: 4px; }
        .output-color-name { background: #eee; padding: 2px 8px; border-radius: 4px; font-family: monospace; }
        .parts-checklist { list-style-type: none; padding-left: 48px; margin: 0 0 8px 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px; }
        .part-item { color: var(--text-color); }
        .part-item input { margin-right: 8px; transform: scale(1.1); }
        .part-item.waiting { color: var(--text-secondary-color); font-style: italic; }
        .part-item.waiting input { cursor: not-allowed; }
        .part-item.completed { text-decoration: line-through; }
        .step-wrapper.is-completed { opacity: 0.6; }
        .step-wrapper.is-target-path { border-left: 4px solid var(--warning-color); background-color: #fffbeb; padding-left: 10px; }
        .completion-notices { padding-left: 48px; }
        .completion-notice { display: flex; align-items: flex-start; color: var(--text-secondary-color); font-size: 0.9em; }
        .completion-notice span { line-height: 1.4; padding-right: 5px; }

        #output-section.invalidated #output { opacity: 0.4; }
        #output-section.invalidated::after { content: 'Schedule outdated. Please regenerate.'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(255, 255, 100, 0.85); border: 1px solid #e0e060; padding: 10px 20px; border-radius: 6px; font-weight: 600; text-align: center; }
        .main-controls { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 20px; }
        #save-feedback { color: var(--secondary-color); font-weight: 600; opacity: 0; transition: opacity 0.3s; }
        #stamp-tool-toolbar { display: none; background-color: var(--bg-color); padding: 15px; border-radius: 6px; margin-bottom: 20px; align-items: center; gap: 15px; border: 1px solid var(--border-color); }
        .stamp-mode-active #stamp-tool-toolbar { display: flex; }
        .stamp-mode-active .add-paint-control, .stamp-mode-active .reorder-btn, .stamp-mode-active .remove-step-btn { display: none; }
        .drop-target { border: 2px dashed var(--border-color); border-radius: 6px; cursor: pointer; transition: all 0.2s; position: relative; }
        .drop-target:hover { border-color: var(--warning-color); background-color: #fff8e1; }
        .drop-target::before { content: '+'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; color: #ccc; transition: color 0.2s; }
        .drop-target:hover::before { color: var(--warning-color); }
        .drop-target.large { width: 50px; height: 32px; }
        .drop-target.small { width: 20px; height: 32px; }
        
        @media (max-width: 900px) {
            .setup-container { grid-template-columns: 1fr; }
            .part-sequence-row { flex-direction: column; align-items: flex-start; }
            .main-controls { flex-direction: column; }
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="card">
            <h1>🎨 Paint Sequencer</h1>
            <input type="text" id="title-input" class="title-input" placeholder="Enter Project Title">
        </div>

        <div class="card">
            <div class="setup-container">
                <div id="paint-management">
                    <div class="card-header"><h2>Available Paints</h2></div>
                    <div class="input-group">
                        <input type="text" id="paint-input" placeholder="Add paints, comma-separated">
                        <button id="add-paint-btn" class="btn-add">Add</button>
                    </div>
                    <ul id="paint-list" class="item-list"></ul>
                </div>
                <div id="part-management">
                    <div class="card-header"><h2>📦 Parts to be Painted</h2></div>
                    <div class="input-group">
                        <input type="text" id="part-input" placeholder="Add parts, comma-separated">
                        <button id="add-part-btn" class="btn-add">Add</button>
                    </div>
                    <ul id="part-list" class="item-list"></ul>
                </div>
            </div>
        </div>

        <div class="card" id="sequence-card">
            <div class="card-header">
                <h2>Assign Paint Sequence</h2>
                <button id="stamp-tool-btn">🖌️ Stamp Tool</button>
            </div>
            <div id="stamp-tool-toolbar">
                <strong>Stamping with:</strong>
                <select id="stamp-color-select"></select>
                <button id="exit-stamp-btn" class="btn-danger">Finish Stamping</button>
            </div>
            <div id="part-sequence-container"><p style="color: var(--text-secondary-color);">Add parts to begin.</p></div>
        </div>
        
        <div class="card">
            <div class="main-controls">
                <button id="save-btn" class="btn-save">💾 Save & Copy Link</button>
                <button id="revert-btn" class="btn-danger" style="display: none;">↩️ Revert Changes</button>
                <button id="generate-btn">✨ Generate Optimal Order</button>
                <button id="reset-progress-btn" class="btn-warning">🔄 Reset Progress</button>
                <button id="reset-btn" class="btn-danger">💣 Reset All</button>
            </div>
            <p style="text-align: center; margin: 10px 0 0 0;"><span id="save-feedback"></span></p>
        </div>

        <div class="card" id="output-section">
            <div class="card-header">
                <div class="header-controls">
                    <h2>✔️ Optimized Schedule</h2>
                    <span id="progress-percentage"></span>
                    <select id="target-part-select" title="Select a part to highlight its critical path"></select>
                    <small class="legend">⭐ Full, ▶️ Partial, 🛑 Blocked</small>
                </div>
            </div>
            <div id="output"><p style="color: var(--text-secondary-color);">Your schedule will appear here.</p></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let state = { projectId: null, title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } };
        let nextPartId = 0;
        let nextPaintId = 0;
        let scheduleData = { steps: [], partToSequence: new Map(), completedTasks: new Set(), currentTargetPartName: null, targetPathStepIds: new Set() };
        
        const saveBtn = document.getElementById('save-btn');
        const revertBtn = document.getElementById('revert-btn');
        const generateBtn = document.getElementById('generate-btn');
        const resetProgressBtn = document.getElementById('reset-progress-btn');
        const resetBtn = document.getElementById('reset-btn');
        const stampToolBtn = document.getElementById('stamp-tool-btn');
        const exitStampBtn = document.getElementById('exit-stamp-btn');
        const addPaintBtn = document.getElementById('add-paint-btn');
        const addPartBtn = document.getElementById('add-part-btn');
        const titleInput = document.getElementById('title-input');
        const paintInput = document.getElementById('paint-input');
        const partInput = document.getElementById('part-input');
        const paintList = document.getElementById('paint-list');
        const partList = document.getElementById('part-list');
        const partSequenceContainer = document.getElementById('part-sequence-container');
        const outputDiv = document.getElementById('output');
        const outputSection = document.getElementById('output-section');
        const progressPercentageEl = document.getElementById('progress-percentage');
        const targetPartSelect = document.getElementById('target-part-select');
        const stampColorSelect = document.getElementById('stamp-color-select');
        
        const sanitizeHTML = str => str.replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[match]);
        const generateId = () => Math.random().toString(36).substring(2, 9);
        const getTaskKey = (partName, color) => `${partName}__${color}`;

        const renderAll = () => { renderTitle(); renderPaintList(); renderPartList(); renderSequenceBuilder(); };
        const renderTitle = () => { titleInput.value = state.title; };
        
        const renderPaintList = () => {
             paintList.innerHTML = state.paints.map(p => `<li data-paint-id="${p.id}"><span class="editable-name" contenteditable="true" data-original-name="${sanitizeHTML(p.name)}">${sanitizeHTML(p.name)}</span><span class="remove-btn" data-paint-id="${p.id}" title="Remove Paint">×</span></li>`).join('');
        };
        const renderPartList = () => {
            partList.innerHTML = state.parts.map(p => `<li><span class="editable-name" contenteditable="true" data-part-id="${p.id}">${sanitizeHTML(p.name)}</span><span class="remove-btn" data-part-id="${p.id}" title="Remove Part">×</span></li>`).join('');
        };
        
        function renderSequenceBuilder() {
            const sequenceCard = document.getElementById('sequence-card');
            partSequenceContainer.innerHTML = '';
            if (state.parts.length === 0) {
                partSequenceContainer.innerHTML = '<p style="color: var(--text-secondary-color);">Add parts to begin.</p>'; return;
            }
            const isStamping = state.stampMode.isActive;
            sequenceCard.classList.toggle('stamp-mode-active', isStamping);
            state.parts.forEach(part => {
                const row = document.createElement('div');
                row.className = 'part-sequence-row';
                row.dataset.partId = part.id;
                let sequenceItems = [];
                if (isStamping) {
                    sequenceItems.push(`<div class="drop-target large" data-insert-index="0"></div>`);
                    part.sequence.forEach((color, index) => {
                        sequenceItems.push(`<div class="paint-step"><span>${sanitizeHTML(color)}</span></div>`);
                        sequenceItems.push(`<div class="drop-target small" data-insert-index="${index + 1}"></div>`);
                    });
                } else {
                    sequenceItems = part.sequence.map((color, index) => `
                        <div class="paint-step">
                            <button class="reorder-btn" data-dir="left" data-index="${index}" title="Move Left">←</button>
                            <span>${sanitizeHTML(color)}</span>
                            <button class="reorder-btn" data-dir="right" data-index="${index}" title="Move Right">→</button>
                            <span class="remove-step-btn" data-index="${index}" title="Remove step">×</span>
                        </div>`);
                }
                let selectOptions = state.paints.map(p => `<option value="${sanitizeHTML(p.name)}">${sanitizeHTML(p.name)}</option>`).join('') || '<option disabled>Add paints first</option>';
                row.innerHTML = `
                    <div class="part-name-label">${sanitizeHTML(part.name)}</div>
                    <div class="sequence-steps">${sequenceItems.join('')}</div>
                    <div class="add-paint-control"><select ${state.paints.length===0?'disabled':''}>${selectOptions}</select><button class="btn-add add-step-btn" ${state.paints.length===0?'disabled':''}>Add</button></div>`;
                partSequenceContainer.appendChild(row);
            });
        }
        
        function markAsUnsavedAndAutoSave() {
            saveBtn.classList.add('unsaved');
            revertBtn.style.display = 'inline-block';
            autoSaveProjectState();
        }

        function markAsSaved() {
            saveBtn.classList.remove('unsaved');
            revertBtn.style.display = 'none';
        }

        function invalidateSchedule() { if (scheduleData.steps.length > 0) outputSection.classList.add('invalidated'); }

        function enterStampMode() {
            if (state.paints.length === 0) { alert("Please add at least one paint color before using the Stamp Tool."); return; }
            state.stampMode.isActive = true;
            stampToolBtn.style.display = 'none';
            document.getElementById('stamp-tool-toolbar').style.display = 'flex';
            stampColorSelect.innerHTML = state.paints.map(p => `<option value="${sanitizeHTML(p.name)}">${sanitizeHTML(p.name)}</option>`).join('');
            state.stampMode.color = stampColorSelect.value;
            renderAll();
        }

        function exitStampMode() { state.stampMode.isActive = false; stampToolBtn.style.display = 'block'; document.getElementById('stamp-tool-toolbar').style.display = 'none'; renderAll(); }
        function handleStampColorChange() { state.stampMode.color = stampColorSelect.value; }
        
        function handleTitleChange() { 
            state.title = titleInput.value; 
            markAsUnsavedAndAutoSave();
        }
        
        function handleAddItems(inputEl, collection, createItem, nameProp = 'name') {
            const values = inputEl.value.split(',').map(v => v.trim()).filter(Boolean);
            if (values.length === 0) return;
            values.forEach(value => { 
                const exists = collection.some(item => item[nameProp] === value);
                if (!exists) collection.push(createItem(value));
            });
            inputEl.value = ''; 
            invalidateSchedule(); 
            markAsUnsavedAndAutoSave(); 
            renderAll();
        }

        function handleAddPaint() { handleAddItems(paintInput, state.paints, value => ({ id: nextPaintId++, name: value }), 'name'); }
        function handleAddPart() { handleAddItems(partInput, state.parts, value => ({ id: nextPartId++, name: value, sequence: [] }), 'name'); }
        
        function handlePaintListClick(e) {
            if (!e.target.matches('.remove-btn')) return;
            const paintId = parseInt(e.target.dataset.paintId);
            const paintToRemove = state.paints.find(p => p.id === paintId);
            if (!paintToRemove) return;

            if (state.parts.some(p => p.sequence.includes(paintToRemove.name))) {
                if (!confirm(`Warning: This will remove "${paintToRemove.name}" from all part sequences. Proceed?`)) return;
                state.parts.forEach(part => { part.sequence = part.sequence.filter(color => color !== paintToRemove.name); });
            }
            state.paints = state.paints.filter(p => p.id !== paintId);
            invalidateSchedule(); 
            markAsUnsavedAndAutoSave(); 
            renderAll();
        }
        function handlePartListClick(e) {
            if (!e.target.matches('.remove-btn')) return;
            const partId = parseInt(e.target.dataset.partId);
            const part = state.parts.find(p => p.id === partId);
            if (part && confirm(`Remove part "${part.name}"?`)) {
                state.parts = state.parts.filter(p => p.id !== partId);
                invalidateSchedule(); 
                markAsUnsavedAndAutoSave(); 
                renderAll();
            }
        }

        function handleNameEdit(e, listType) {
            const target = e.target;
            const saveEdit = () => {
                const newValue = target.textContent.trim();
                let oldValue;
                let isDuplicate = false;

                if (listType === 'paint') {
                    const paintId = parseInt(target.closest('li').dataset.paintId);
                    const paint = state.paints.find(p => p.id === paintId);
                    if (!paint) return;
                    oldValue = paint.name;
                    isDuplicate = state.paints.some(p => p.name === newValue && p.id !== paintId);
                } else { // part
                    const partId = parseInt(target.dataset.partId);
                    const part = state.parts.find(p => p.id === partId);
                    if (!part) return;
                    oldValue = part.name;
                    isDuplicate = state.parts.some(p => p.name === newValue && p.id !== partId);
                }
                
                if (newValue === oldValue) return;
                if (!newValue) { alert("Name cannot be empty."); target.textContent = oldValue; return; }
                if (isDuplicate) { alert(`Name "${newValue}" already exists.`); target.textContent = oldValue; return; }
                
                const newCompletedTasks = new Set();
                scheduleData.completedTasks.forEach(taskKey => {
                    let [partName, paintName] = taskKey.split('__');
                    if (listType === 'paint' && paintName === oldValue) { paintName = newValue; } 
                    else if (listType === 'part' && partName === oldValue) { partName = newValue; }
                    newCompletedTasks.add(getTaskKey(partName, paintName));
                });
                scheduleData.completedTasks = newCompletedTasks;
                saveProgressToLocalStorage();

                if (listType === 'paint') {
                    const paint = state.paints.find(p => p.name === oldValue);
                    if (paint) paint.name = newValue;
                    state.parts.forEach(p => { p.sequence = p.sequence.map(c => c === oldValue ? newValue : c); });
                    scheduleData.steps.forEach(s => { if(s.color === oldValue) s.color = newValue; });
                } else { // part
                    const part = state.parts.find(p => p.name === oldValue);
                    if (part) part.name = newValue;
                    scheduleData.steps.forEach(s => { s.partList = s.partList.map(p => p === oldValue ? newValue : p); });
                    scheduleData.partToSequence.forEach((seq, key) => { if(key === oldValue) { scheduleData.partToSequence.delete(key); scheduleData.partToSequence.set(newValue, seq); }});
                    if(scheduleData.currentTargetPartName === oldValue) scheduleData.currentTargetPartName = newValue;
                }
                
                markAsUnsavedAndAutoSave();
                renderAll();
                updateScheduleView();
            };

            if (e.type === 'keydown') {
                if(e.key === 'Enter') { e.preventDefault(); target.blur(); } 
                else if (e.key === 'Escape') {
                    target.textContent = target.dataset.originalName;
                    target.blur();
                }
            } else if (e.type === 'blur') {
                saveEdit();
            }
        }
        
        function handleSequenceInteraction(e) {
            const partRow = e.target.closest('.part-sequence-row');
            if (!partRow) return;
            const part = state.parts.find(p => p.id === parseInt(partRow.dataset.partId));
            if (!part) return;
            if (state.stampMode.isActive && e.target.matches('.drop-target')) {
                const insertIndex = parseInt(e.target.dataset.insertIndex);
                part.sequence.splice(insertIndex, 0, state.stampMode.color);
                invalidateSchedule(); markAsUnsavedAndAutoSave(); renderAll(); return;
            }
            let stateChanged = false;
            if (e.target.matches('.add-step-btn')) {
                const select = partRow.querySelector('select');
                if (select.value) { part.sequence.push(select.value); stateChanged = true; }
            } else if (e.target.matches('.remove-step-btn')) {
                part.sequence.splice(parseInt(e.target.dataset.index), 1); stateChanged = true;
            } else if (e.target.matches('.reorder-btn')) {
                const index = parseInt(e.target.dataset.index); const dir = e.target.dataset.dir;
                if (dir === 'left' && index > 0) { [part.sequence[index], part.sequence[index - 1]] = [part.sequence[index - 1], part.sequence[index]]; stateChanged = true; } 
                else if (dir === 'right' && index < part.sequence.length - 1) { [part.sequence[index], part.sequence[index + 1]] = [part.sequence[index + 1], part.sequence[index]]; stateChanged = true; }
            }
            if (stateChanged) { invalidateSchedule(); markAsUnsavedAndAutoSave(); renderAll(); }
        }

        function generateOptimalOrder() {
            if (state.parts.filter(p => p.sequence.length === 0).length > 0) {
                if (!confirm(`Warning: Some parts have no paint sequence and will be ignored. Continue?`)) return;
            }
            _resetSchedule(false); // Keep progress but clear old schedule
            
            let partsToProcess = JSON.parse(JSON.stringify(state.parts)).filter(p => p.sequence.length > 0).map(p => ({ ...p, currentStep: 0, originalSequence: p.sequence }));
            if (partsToProcess.length === 0) {
                outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">No parts with paint sequences.</p>'; return;
            }
            
            let stepIdCounter = 0;
            while (partsToProcess.some(p => p.currentStep < p.sequence.length)) {
                const readyPartsByColor = new Map();
                partsToProcess.filter(p=>p.currentStep < p.sequence.length).forEach(part => {
                    const nextColor = part.sequence[part.currentStep];
                    if (!readyPartsByColor.has(nextColor)) readyPartsByColor.set(nextColor, []);
                    readyPartsByColor.get(nextColor).push(part);
                });
                
                let priorityChoices = [], lastStepChoices = [];
                for (const [color, partList] of readyPartsByColor.entries()) {
                    (partList.some(p => p.currentStep < p.sequence.length - 1) ? priorityChoices : lastStepChoices).push({ color, partList, count: partList.length });
                }
                const choices = priorityChoices.length > 0 ? priorityChoices : lastStepChoices;
                choices.sort((a, b) => b.count - a.count);
                if (choices.length === 0) break;
                
                const bestChoice = choices[0];
                const stepId = stepIdCounter++;
                scheduleData.steps.push({ id: stepId, color: bestChoice.color, partList: bestChoice.partList.map(p => p.name) });
                bestChoice.partList.forEach(part => { part.currentStep++; });
            }

            state.parts.forEach(part => { scheduleData.partToSequence.set(part.name, part.sequence); });
            outputSection.classList.remove('invalidated');
            renderTargetPartSelector();
            updateScheduleView();
        }
        
        function renderTargetPartSelector() {
            targetPartSelect.innerHTML = '<option value="">Default (No Target)</option>';
            const sortedPartNames = Array.from(scheduleData.partToSequence.keys()).sort();
            sortedPartNames.forEach(name => {
                targetPartSelect.innerHTML += `<option value="${sanitizeHTML(name)}">${sanitizeHTML(name)}</option>`;
            });
            targetPartSelect.value = scheduleData.currentTargetPartName || "";
        }
        
        function updateTargetPath() {
            scheduleData.targetPathStepIds.clear();
            const { currentTargetPartName, partToSequence, steps } = scheduleData;
            if (!currentTargetPartName) return;

            const targetSequence = partToSequence.get(currentTargetPartName);
            if (!targetSequence) return;
            
            let requiredTasks = new Set(targetSequence.map(color => getTaskKey(currentTargetPartName, color)));
            let toProcess = [...requiredTasks];
            while (toProcess.length > 0) {
                const taskKey = toProcess.pop();
                const [partName, color] = taskKey.split('__');
                const sequence = partToSequence.get(partName);
                if(!sequence) continue;
                const colorIndex = sequence.indexOf(color);

                if (colorIndex > 0) {
                    const prereqTaskKey = getTaskKey(partName, sequence[colorIndex - 1]);
                    if (!requiredTasks.has(prereqTaskKey)) {
                        requiredTasks.add(prereqTaskKey);
                        toProcess.push(prereqTaskKey);
                    }
                }
            }

            steps.forEach(step => {
                for (const partName of step.partList) {
                    if (requiredTasks.has(getTaskKey(partName, step.color))) {
                        scheduleData.targetPathStepIds.add(step.id);
                        break;
                    }
                }
            });
        }
        
        function isPartStartable(partName, color) {
            const sequence = scheduleData.partToSequence.get(partName);
            if (!sequence) return false;
            
            const colorIndex = sequence.indexOf(color);
            if(colorIndex <= 0) return true;

            const prereqColor = sequence[colorIndex - 1];
            return scheduleData.completedTasks.has(getTaskKey(partName, prereqColor));
        }

        function createStepWrapper(stepInfo) {
            const wrapper = document.createElement('div');
            wrapper.className = 'step-wrapper';

            let indicatorIcon = '🛑'; let indicatorTitle = 'No parts are ready yet.'; let indicatorClass = 'stop';
            
            const remainingPartsInStep = stepInfo.partList.length - stepInfo.completedCount;
            if (remainingPartsInStep > 0) {
                if (stepInfo.startableCount === remainingPartsInStep) {
                    indicatorIcon = '⭐'; indicatorTitle = 'All remaining parts are ready.'; indicatorClass = 'full';
                } else if (stepInfo.startableCount > 0) {
                    indicatorIcon = '▶️'; indicatorTitle = 'Some parts are ready.'; indicatorClass = 'partial';
                }
            }

            if (stepInfo.completedCount === stepInfo.partList.length) wrapper.classList.add('is-completed');
            if(scheduleData.targetPathStepIds.has(stepInfo.id)) wrapper.classList.add('is-target-path');
            
            let countText = '';
            if(stepInfo.startableCount > 0) countText = ` (${stepInfo.startableCount} of ${remainingPartsInStep} ready)`;
            
            wrapper.innerHTML = `
                <div class="step-header">
                    <span class="start-indicator ${indicatorClass}" title="${indicatorTitle}">${indicatorIcon}</span>
                    <span class="step-action">Load <code class="output-color-name">${sanitizeHTML(stepInfo.color)}</code>${countText}</span>
                    <label class="check-all-label">
                        <input type="checkbox" class="master-checkbox" data-step-id="${stepInfo.id}" ${stepInfo.startableCount === 0 ? 'disabled' : ''}> Check All Ready
                    </label>
                </div>
                <ul class="parts-checklist">${generatePartListHTML(stepInfo)}</ul>
                <div class="completion-notices">${generateCompletionNoticesHTML(stepInfo)}</div>`;
            return wrapper;
        }

        function createMergedStepWrapper(stepGroup) {
            const wrapper = document.createElement('div');
            wrapper.className = 'step-wrapper';
            
            const allOriginalIds = stepGroup.map(s => s.id);
            const isTargetPath = allOriginalIds.some(id => scheduleData.targetPathStepIds.has(id));
            if(isTargetPath) wrapper.classList.add('is-target-path');

            const totalStartable = stepGroup.reduce((sum, s) => sum + s.startableCount, 0);
            const totalRemaining = stepGroup.reduce((sum, s) => sum + (s.partList.length - s.completedCount), 0);
            let countText = ` (${totalStartable} of ${totalRemaining} ready)`;
            
            const masterCheck = `<label class="check-all-label">
                <input type="checkbox" class="master-checkbox" data-original-step-ids="${allOriginalIds.join(',')}" ${totalStartable === 0 ? 'disabled' : ''}> Check All Ready
            </label>`;
            
            let partListHTML = ''; let noticesHTML = '';
            stepGroup.forEach(stepInfo => {
                partListHTML += generatePartListHTML(stepInfo);
                noticesHTML += generateCompletionNoticesHTML(stepInfo);
            });

            wrapper.innerHTML = `
                <div class="step-header">
                    <span class="start-indicator full" title="All remaining parts are ready.">⭐</span>
                    <span class="step-action">Load <code class="output-color-name">${sanitizeHTML(stepGroup[0].color)}</code>${countText}</span>
                    ${masterCheck}
                </div>
                <ul class="parts-checklist">${partListHTML}</ul>
                <div class="completion-notices">${noticesHTML}</div>`;
            return wrapper;
        }
        
        function generatePartListHTML(stepInfo) {
            return stepInfo.partList.sort().map(partName => {
                const taskKey = getTaskKey(partName, stepInfo.color);
                const isCompleted = scheduleData.completedTasks.has(taskKey);
                const canStart = !isCompleted && isPartStartable(partName, stepInfo.color);
                let classes = 'part-item';
                if (isCompleted) classes += ' completed';
                if (!canStart && !isCompleted) classes += ' waiting';
                return `<li class="${classes}"><label>
                        <input type="checkbox" class="part-checkbox" data-part-name="${sanitizeHTML(partName)}" data-color="${sanitizeHTML(stepInfo.color)}" ${isCompleted ? 'checked' : ''} ${!canStart && !isCompleted ? 'disabled' : ''}>
                        ${sanitizeHTML(partName)}</label></li>`;
            }).join('');
        }
        
        function generateCompletionNoticesHTML(stepInfo) {
            let html = '';
            const willCompleteParts = [], didCompleteParts = [];

            stepInfo.partList.forEach(partName => {
                const sequence = scheduleData.partToSequence.get(partName);
                if (sequence && sequence[sequence.length - 1] === stepInfo.color) {
                    if (scheduleData.completedTasks.has(getTaskKey(partName, stepInfo.color))) { didCompleteParts.push(partName); } 
                    else { willCompleteParts.push(partName); }
                }
            });

            if (willCompleteParts.length > 0) html += `<div class="completion-notice"><span>🏆</span><div>Will complete: <strong>${willCompleteParts.map(sanitizeHTML).sort().join(', ')}</strong></div></div>`;
            if (didCompleteParts.length > 0) html += `<div class="completion-notice"><span>✔️</span><div>Completed: <strong>${didCompleteParts.map(sanitizeHTML).sort().join(', ')}</strong></div></div>`;
            return html;
        }

        function updateScheduleView() {
            if (scheduleData.steps.length === 0) return;
            outputDiv.innerHTML = '';
            calculateProgress();

            const stepInfos = scheduleData.steps.map(step => {
                let completedCount = 0, startableCount = 0;
                step.partList.forEach(partName => {
                    const isCompleted = scheduleData.completedTasks.has(getTaskKey(partName, step.color));
                    if(isCompleted) completedCount++;
                    else if(isPartStartable(partName, step.color)) startableCount++;
                });
                return { ...step, completedCount, startableCount };
            });

            const completedSteps = [], fullyReadySteps = [], partiallyReadySteps = [], waitingSteps = [];
            stepInfos.forEach(stepInfo => {
                const remainingParts = stepInfo.partList.length - stepInfo.completedCount;
                if (remainingParts === 0) completedSteps.push(stepInfo);
                else if (stepInfo.startableCount === remainingParts) fullyReadySteps.push(stepInfo);
                else if (stepInfo.startableCount > 0) partiallyReadySteps.push(stepInfo);
                else waitingSteps.push(stepInfo);
            });
            
            const mergedReadyGroups = new Map();
            fullyReadySteps.forEach(stepInfo => {
                if(!mergedReadyGroups.has(stepInfo.color)) mergedReadyGroups.set(stepInfo.color, []);
                mergedReadyGroups.get(stepInfo.color).push(stepInfo);
            });
            
            completedSteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
            mergedReadyGroups.forEach(group => outputDiv.appendChild(createMergedStepWrapper(group)));
            partiallyReadySteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
            waitingSteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
        }
        
        function calculateProgress() {
            const { partToSequence, completedTasks } = scheduleData;
            if (!partToSequence || partToSequence.size === 0) { progressPercentageEl.textContent = ''; return;}
            
            let fullyCompletedPartsCount = 0;
            partToSequence.forEach((sequence, partName) => {
                if (sequence.every(color => completedTasks.has(getTaskKey(partName, color)))) fullyCompletedPartsCount++;
            });
            const percentage = Math.round((fullyCompletedPartsCount / partToSequence.size) * 100);
            progressPercentageEl.textContent = `Progress: ${percentage}%`;
        }

        function handleOutputChange(e) {
            const target = e.target;
            function toggleTask(partName, color, shouldBeChecked) {
                const taskKey = getTaskKey(partName, color);
                if (shouldBeChecked) scheduleData.completedTasks.add(taskKey); else scheduleData.completedTasks.delete(taskKey);
            }

            if (target.matches('.part-checkbox')) {
                toggleTask(target.dataset.partName, target.dataset.color, target.checked);
            } else if (target.matches('.master-checkbox')) {
                const isChecking = target.checked;
                const stepIds = (target.dataset.originalStepIds || target.dataset.stepId).split(',').map(Number);
                stepIds.forEach(stepId => {
                    const step = scheduleData.steps.find(s => s.id === stepId);
                    if (!step) return;
                    step.partList.forEach(partName => {
                        if (!scheduleData.completedTasks.has(getTaskKey(partName, step.color)) && isPartStartable(partName, step.color)) {
                            toggleTask(partName, step.color, isChecking);
                        }
                    });
                });
            } else { return; }
            
            saveProgressToLocalStorage();
            updateScheduleView();
        }

        function autoSaveProjectState() {
            if (!state.projectId) return;
            const key = `paintSequencerProject_${state.projectId}`;
            try { localStorage.setItem(key, JSON.stringify(state)); } 
            catch (e) { console.error("Could not auto-save project state:", e); }
        }

        function saveProgressToLocalStorage() {
            if (!state.projectId) return;
            const key = `paintSequencerProgress_${state.projectId}`;
            try { localStorage.setItem(key, JSON.stringify(Array.from(scheduleData.completedTasks))); } 
            catch (e) { console.error("Could not save progress:", e); }
        }
        
        function clearAutoSavedProjectState() {
            if (!state.projectId) return;
            localStorage.removeItem(`paintSequencerProject_${state.projectId}`);
        }

        function saveStateToURL() {
            const stateToSave = { ...state };
            const jsonState = JSON.stringify(stateToSave);
            const base64State = btoa(unescape(encodeURIComponent(jsonState)));
            window.location.hash = base64State;
            navigator.clipboard.writeText(window.location.href).then(() => {
                const saveFeedback = document.getElementById('save-feedback');
                saveFeedback.textContent = 'Saved! Link copied to clipboard.';
                saveFeedback.style.opacity = '1';
                setTimeout(() => { saveFeedback.style.opacity = '0'; }, 3000);
            });
            clearAutoSavedProjectState();
            markAsSaved();
        }

        function decodeStateFromURL() {
            if (!window.location.hash) return null;
            try {
                const jsonState = decodeURIComponent(escape(atob(window.location.hash.substring(1))));
                let loadedState = JSON.parse(jsonState);

                if (loadedState && loadedState.paints && loadedState.parts) {
                    if (loadedState.paints.length > 0 && typeof loadedState.paints[0] === 'string') {
                        let currentPaintId = 0;
                        loadedState.paints = loadedState.paints.map(pName => ({ id: currentPaintId++, name: pName }));
                    }
                    if (!loadedState.projectId) loadedState.projectId = generateId();
                    return loadedState;
                }
            } catch (e) {
                console.error("Failed to load state from URL hash:", e);
                alert("Could not load project from link. The link may be corrupted.");
            }
            return null;
        }

        function loadAutoSavedProjectState(projectId) {
            if (!projectId) return null;
            const key = `paintSequencerProject_${projectId}`;
            const savedData = localStorage.getItem(key);
            if (savedData) {
                try { return JSON.parse(savedData); }
                catch (e) { console.error("Failed to parse auto-saved project state:", e); return null; }
            }
            return null;
        }
        
        function loadProgressFromLocalStorage(projectId) {
            scheduleData.completedTasks = new Set();
            if (!projectId) return;
            const key = `paintSequencerProgress_${projectId}`;
            const savedData = localStorage.getItem(key);
            if (savedData) {
                try { scheduleData.completedTasks = new Set(JSON.parse(savedData)); } 
                catch(e) { console.error("Failed to parse progress from localStorage:", e); }
            }
        }

        function handleRevert() {
            if (confirm("Discard all unsaved changes and revert to the last saved version of this project?")) {
                clearAutoSavedProjectState();
                window.location.reload();
            }
        }

        function handleResetProgress() {
            if (confirm("Are you sure you want to reset all progress for this project? All checkboxes will be cleared.")) {
                scheduleData.completedTasks.clear();
                saveProgressToLocalStorage();
                updateScheduleView();
            }
        }

        function _resetSchedule(clearProgress = true) {
            scheduleData.steps = [];
            scheduleData.partToSequence = new Map();
            scheduleData.currentTargetPartName = null;
            scheduleData.targetPathStepIds = new Set();
            if (clearProgress && state.projectId) {
                scheduleData.completedTasks = new Set();
                saveProgressToLocalStorage();
            }
            outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">Your schedule will appear here.</p>';
            progressPercentageEl.textContent = '';
            targetPartSelect.innerHTML = '';
            outputSection.classList.remove('invalidated');
        }

        function _performReset() {
            if(state.projectId) {
                localStorage.removeItem(`paintSequencerProgress_${state.projectId}`);
                localStorage.removeItem(`paintSequencerProject_${state.projectId}`);
            }
            state = { projectId: generateId(), title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } };
            nextPartId = 0; nextPaintId = 0;
            _resetSchedule(true);
            history.pushState("", document.title, window.location.pathname + window.location.search);
            exitStampMode();
            markAsSaved();
        }

        function handleReset() { if (confirm('Reset everything? This will clear all data, including auto-saves and progress for this project.')) { _performReset(); renderAll(); } }
        
        function loadInitialData() {
            _performReset();
            state.title = 'HG Gundam "Paint-by-Numbers"';
            state.paints = [
                {id: nextPaintId++, name: 'Primer'}, {id: nextPaintId++, name: 'Frame Gray'}, {id: nextPaintId++, name: 'Armor White'}, 
                {id: nextPaintId++, name: 'Gundam Blue'}, {id: nextPaintId++, name: 'Fin Red'}, {id: nextPaintId++, name: 'V-Fin Yellow'}, 
                {id: nextPaintId++, name: 'Gloss Clearcoat'}
            ];
            state.parts.push(
                { id: nextPartId++, name: 'A-13 (Chest)', sequence: ['Primer', 'Gundam Blue', 'Armor White', 'Gloss Clearcoat'] },
                { id: nextPartId++, name: 'B-4 (Skirt)', sequence: ['Primer', 'Gundam Blue', 'Gloss Clearcoat']},
                { id: nextPartId++, name: 'C-2, C-5 (Leg Frame)', sequence: ['Frame Gray'] },
                { id: nextPartId++, name: 'D-1 (Shield)', sequence: ['Primer', 'Fin Red', 'Armor White', 'Gloss Clearcoat'] },
                { id: nextPartId++, name: 'F-9 (V-Fin)', sequence: ['Primer', 'V-Fin Yellow', 'Gloss Clearcoat'] }
            );
            markAsUnsavedAndAutoSave();
            renderAll();
        }
        
        function initializeApp() {
            const getDefaultState = () => ({ projectId: null, title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } });
            state = getDefaultState();
            
            let stateFromURL = decodeStateFromURL();
            let projectId = stateFromURL ? stateFromURL.projectId : null;
            let autoSavedState = projectId ? loadAutoSavedProjectState(projectId) : null;
            
            if (autoSavedState) {
                state = { ...getDefaultState(), ...autoSavedState };
                markAsUnsavedAndAutoSave();
            } else if (stateFromURL) {
                state = { ...getDefaultState(), ...stateFromURL };
                markAsSaved();
            } else {
                loadInitialData(); // This calls _performReset and sets up the example
                return; // Exit early since loadInitialData handles rendering.
            }

            nextPartId = state.parts.reduce((max, p) => Math.max(max, p.id), -1) + 1;
            nextPaintId = state.paints.reduce((max, p) => Math.max(max, p.id), -1) + 1;
            
            loadProgressFromLocalStorage(state.projectId);
            renderAll();
            generateOptimalOrder();
        }
        
        // EVENT LISTENERS
        addPaintBtn.addEventListener('click', handleAddPaint);
        paintInput.addEventListener('keydown', e => e.key === 'Enter' && handleAddPaint());
        paintList.addEventListener('click', handlePaintListClick);
        paintList.addEventListener('blur', (e) => handleNameEdit(e, 'paint'), true);
        paintList.addEventListener('keydown', (e) => handleNameEdit(e, 'paint'), true);
        addPartBtn.addEventListener('click', handleAddPart);
        partInput.addEventListener('keydown', e => e.key === 'Enter' && handleAddPart());
        partList.addEventListener('click', handlePartListClick);
        partList.addEventListener('blur', (e) => handleNameEdit(e, 'part'), true);
        partList.addEventListener('keydown', (e) => handleNameEdit(e, 'part'), true);
        partSequenceContainer.addEventListener('click', handleSequenceInteraction);
        titleInput.addEventListener('input', handleTitleChange);
        saveBtn.addEventListener('click', saveStateToURL);
        revertBtn.addEventListener('click', handleRevert);
        generateBtn.addEventListener('click', generateOptimalOrder);
        resetProgressBtn.addEventListener('click', handleResetProgress);
        resetBtn.addEventListener('click', handleReset);
        stampToolBtn.addEventListener('click', enterStampMode);
        exitStampBtn.addEventListener('click', exitStampMode);
        stampColorSelect.addEventListener('change', handleStampColorChange);
        outputDiv.addEventListener('change', handleOutputChange);
        targetPartSelect.addEventListener('change', () => {
            scheduleData.currentTargetPartName = targetPartSelect.value || null;
            updateTargetPath();
            updateScheduleView();
        });
        
        // INITIALIZATION
        initializeApp();
    });
    </script>
</body>
</html>
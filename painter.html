<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Sequencer</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #1c1e21;
            --text-secondary-color: #606770;
            --primary-color: #1877f2;
            --primary-hover-color: #166fe5;
            --secondary-color: #42b72a;
            --secondary-hover-color: #36a420;
            --danger-color: #fa383e;
            --border-color: #dddfe2;
            --stamp-color: #ffc107;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        body { font-family: var(--font-family); line-height: 1.6; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 24px; }
        .container { max-width: 1200px; margin: 0 auto; display: flex; flex-direction: column; gap: 24px; }
        .card { background-color: var(--surface-color); box-shadow: var(--shadow); border-radius: 8px; padding: 20px; position: relative; }
        .card-header { display: flex; justify-content: space-between; align-items: baseline; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px; flex-wrap: wrap; gap: 10px; }
        .card-header h2 { border: none; padding: 0; margin: 0; }
        .card-header .legend { color: var(--text-secondary-color); font-size: 0.9em; white-space: nowrap; }
        .header-controls { display: contents; } /* Allows items to flow with flexbox */
        #progress-percentage { font-weight: 600; color: var(--primary-color); margin-left: auto; padding: 0 10px;}
        #target-part-select { padding: 4px 8px; border-radius: 6px; border: 1px solid var(--border-color); font-size: 0.9em; }
        h1 { font-size: 1.8rem; margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px;}
        .title-input { font-size: 1.2rem; font-weight: 600; border: none; border-bottom: 2px solid transparent; width: 100%; padding: 4px; margin-bottom: 20px; transition: border-color 0.2s; }
        .title-input:focus { outline: none; border-bottom-color: var(--primary-color); }
        .setup-container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
        .input-group { display: flex; gap: 8px; margin-bottom: 15px; }
        .input-group input { flex-grow: 1; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 1rem; }
        .input-group button { white-space: nowrap; }
        button { padding: 10px 18px; background-color: var(--primary-color); color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: background-color 0.2s, opacity 0.2s; }
        button:hover { background-color: var(--primary-hover-color); }
        .btn-add, .btn-save.unsaved { background-color: var(--secondary-color); }
        .btn-add:hover, .btn-save.unsaved:hover { background-color: var(--secondary-hover-color); }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: #e03238; }
        .btn-stamp { background-color: var(--stamp-color); color: var(--text-color); }
        .btn-stamp:hover { background-color: #e0ac00; }
        .item-list { list-style-type: none; padding: 0; display: flex; flex-wrap: wrap; gap: 10px; }
        .item-list li { display: flex; align-items: center; background-color: var(--bg-color); border-radius: 15px; padding: 5px 5px 5px 12px; font-size: 0.9rem; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .editable-name { cursor: text; padding: 2px 4px; border-radius: 3px; }
        .editable-name[contenteditable]:focus { outline: 2px solid var(--primary-color); background-color: #eaf3ff; }
        .remove-btn { background: #ccc; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; line-height: 20px; text-align: center; cursor: pointer; margin-left: 8px; font-weight: bold; transition: background-color 0.2s; }
        .remove-btn:hover { background-color: #a0a0a0; }
        .part-sequence-row { display: flex; align-items: center; gap: 15px; padding: 12px 0; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        .part-sequence-row:last-child { border-bottom: none; }
        .part-name-label { font-weight: 600; width: 150px; flex-shrink: 0; }
        .sequence-steps { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; flex-grow: 1; }
        .paint-step { display: flex; align-items: center; gap: 6px; background: #e4e6eb; border-radius: 6px; padding: 4px; position: relative; }
        .reorder-btn { display: inline-flex; align-items: center; justify-content: center; background: none; border: 1px solid #ccc; color: #888; border-radius: 50%; width: 22px; height: 22px; padding: 0; font-size: 14px; line-height: 1; text-align: center; cursor: pointer; transition: all 0.2s; }
        .reorder-btn:hover { background-color: #ddd; border-color: #aaa; color: #333; }
        .paint-step .remove-step-btn { color: #aaa; cursor: pointer; font-weight: bold; padding: 0 4px; }
        .paint-step .remove-step-btn:hover { color: var(--danger-color); }
        .add-paint-control select, #stamp-color-select { padding: 6px; border-radius: 6px; border: 1px solid var(--border-color); }
        .add-paint-control button { font-size: 0.9rem; padding: 6px 12px; }
        
        #output { border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; background: #f8f9fa; min-height: 100px; transition: opacity 0.3s; }
        .step-wrapper { padding: 10px 0; border-bottom: 1px solid var(--border-color); transition: background-color 0.3s, border 0.3s; }
        .step-wrapper:last-child { border-bottom: none; }
        .step-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .start-indicator { font-size: 1.5rem; line-height: 1; width: 24px; text-align: center; cursor: help;}
        .start-indicator.full { color: var(--stamp-color); }
        .start-indicator.partial { color: var(--primary-color); }
        .start-indicator.stop { color: var(--danger-color); }
        .step-action { font-weight: 600; flex-grow: 1; }
        .check-all-label { white-space: nowrap; font-size: 0.9em; color: var(--text-secondary-color); }
        .check-all-label input { margin-right: 4px; }
        .output-color-name { background: #eee; padding: 2px 8px; border-radius: 4px; font-family: monospace; }
        .parts-checklist { list-style-type: none; padding-left: 48px; margin: 0 0 8px 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px; }
        .part-item { color: var(--text-color); }
        .part-item input { margin-right: 8px; transform: scale(1.1); }
        .part-item.waiting { color: var(--text-secondary-color); font-style: italic; }
        .part-item.waiting input { cursor: not-allowed; }
        .part-item.completed { text-decoration: line-through; }
        .step-wrapper.is-completed { opacity: 0.6; }
        .step-wrapper.is-target-path { border-left: 4px solid var(--stamp-color); background-color: #fffbeb; padding-left: 10px; }
        .completion-notices { padding-left: 48px; }
        .completion-notice { display: flex; align-items: flex-start; color: var(--text-secondary-color); font-size: 0.9em; }
        .completion-notice span { line-height: 1.4; padding-right: 5px; }

        #output-section.invalidated #output { opacity: 0.4; }
        #output-section.invalidated::after { content: 'Schedule outdated. Please regenerate.'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(255, 255, 100, 0.85); border: 1px solid #e0e060; padding: 10px 20px; border-radius: 6px; font-weight: 600; text-align: center; }
        .main-controls { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 20px; }
        #save-feedback { color: var(--secondary-color); font-weight: 600; opacity: 0; transition: opacity 0.3s; }
        #stamp-tool-toolbar { display: none; background-color: var(--bg-color); padding: 15px; border-radius: 6px; margin-bottom: 20px; align-items: center; gap: 15px; border: 1px solid var(--border-color); }
        .stamp-mode-active #stamp-tool-toolbar { display: flex; }
        .stamp-mode-active .add-paint-control, .stamp-mode-active .reorder-btn, .stamp-mode-active .remove-step-btn { display: none; }
        .drop-target { border: 2px dashed var(--border-color); border-radius: 6px; cursor: pointer; transition: all 0.2s; position: relative; }
        .drop-target:hover { border-color: var(--stamp-color); background-color: #fff8e1; }
        .drop-target::before { content: '+'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; color: #ccc; transition: color 0.2s; }
        .drop-target:hover::before { color: var(--stamp-color); }
        .drop-target.large { width: 50px; height: 32px; }
        .drop-target.small { width: 20px; height: 32px; }
        
        @media (max-width: 900px) {
            .setup-container { grid-template-columns: 1fr; }
            .part-sequence-row { flex-direction: column; align-items: flex-start; }
            .main-controls { flex-direction: column; }
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="card">
            <h1>🎨 Paint Sequencer</h1>
            <input type="text" id="title-input" class="title-input" placeholder="Enter Project Title">
        </div>

        <div class="card">
            <div class="setup-container">
                <div id="paint-management">
                    <div class="card-header"><h2>Available Paints</h2></div>
                    <div class="input-group">
                        <input type="text" id="paint-input" placeholder="Add paints, comma-separated">
                        <button id="add-paint-btn" class="btn-add">Add</button>
                    </div>
                    <ul id="paint-list" class="item-list"></ul>
                </div>
                <div id="part-management">
                    <div class="card-header"><h2>📦 Parts to be Painted</h2></div>
                    <div class="input-group">
                        <input type="text" id="part-input" placeholder="Add parts, comma-separated">
                        <button id="add-part-btn" class="btn-add">Add</button>
                    </div>
                    <ul id="part-list" class="item-list"></ul>
                </div>
            </div>
        </div>

        <div class="card" id="sequence-card">
            <div class="card-header">
                <h2>Assign Paint Sequence</h2>
                <button id="stamp-tool-btn" class="btn-stamp">🖌️ Stamp Tool</button>
            </div>
            <div id="stamp-tool-toolbar">
                <strong>Stamping with:</strong>
                <select id="stamp-color-select"></select>
                <button id="exit-stamp-btn" class="btn-danger">Finish Stamping</button>
            </div>
            <div id="part-sequence-container"><p style="color: var(--text-secondary-color);">Add parts to begin.</p></div>
        </div>
        
        <div class="card">
            <div class="main-controls">
                <button id="save-btn" class="btn-save">💾 Save & Copy Link</button>
                <button id="generate-btn">✨ Generate Optimal Order</button>
                <button id="reset-btn" class="btn-danger">🔄 Reset All</button>
            </div>
            <p style="text-align: center; margin: 10px 0 0 0;"><span id="save-feedback"></span></p>
        </div>

        <div class="card" id="output-section">
            <div class="card-header">
                <div class="header-controls">
                    <h2>✔️ Optimized Schedule</h2>
                    <span id="progress-percentage"></span>
                    <select id="target-part-select" title="Select a part to highlight its critical path"></select>
                    <small class="legend">⭐ Full, ▶️ Partial, 🛑 Blocked</small>
                </div>
            </div>
            <div id="output"><p style="color: var(--text-secondary-color);">Your schedule will appear here.</p></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let state = { title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } };
        let nextPartId = 0;
        let scheduleData = { steps: [], completedPartsByStepId: new Map(), partSequenceStepIds: new Map(), currentTargetPartName: null, targetPathStepIds: new Set() };

        const stampToolBtn = document.getElementById('stamp-tool-btn');
        const stampColorSelect = document.getElementById('stamp-color-select');
        const exitStampBtn = document.getElementById('exit-stamp-btn');
        const titleInput = document.getElementById('title-input');
        const saveBtn = document.getElementById('save-btn');
        const paintInput = document.getElementById('paint-input');
        const addPaintBtn = document.getElementById('add-paint-btn');
        const paintList = document.getElementById('paint-list');
        const partInput = document.getElementById('part-input');
        const addPartBtn = document.getElementById('add-part-btn');
        const partList = document.getElementById('part-list');
        const partSequenceContainer = document.getElementById('part-sequence-container');
        const generateBtn = document.getElementById('generate-btn');
        const resetBtn = document.getElementById('reset-btn');
        const outputSection = document.getElementById('output-section');
        const outputDiv = document.getElementById('output');
        const progressPercentageEl = document.getElementById('progress-percentage');
        const targetPartSelect = document.getElementById('target-part-select');
        
        const sanitizeHTML = str => str.replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[match]);

        const renderAll = () => { renderTitle(); renderPaintList(); renderPartList(); renderSequenceBuilder(); };
        const renderTitle = () => { titleInput.value = state.title; };
        
        const renderPaintList = () => {
             paintList.innerHTML = state.paints.map(p => `<li><span class="editable-name" contenteditable="true" data-original-name="${sanitizeHTML(p)}">${sanitizeHTML(p)}</span><span class="remove-btn" data-paint-name="${sanitizeHTML(p)}" title="Remove Paint">×</span></li>`).join('');
        };
        const renderPartList = () => {
            partList.innerHTML = state.parts.map(p => `<li><span class="editable-name" contenteditable="true" data-part-id="${p.id}">${sanitizeHTML(p.name)}</span><span class="remove-btn" data-part-id="${p.id}" title="Remove Part">×</span></li>`).join('');
        };
        
        function renderSequenceBuilder() {
            const sequenceCard = document.getElementById('sequence-card');
            partSequenceContainer.innerHTML = '';
            if (state.parts.length === 0) {
                partSequenceContainer.innerHTML = '<p style="color: var(--text-secondary-color);">Add parts to begin.</p>'; return;
            }
            const isStamping = state.stampMode.isActive;
            sequenceCard.classList.toggle('stamp-mode-active', isStamping);
            state.parts.forEach(part => {
                const row = document.createElement('div');
                row.className = 'part-sequence-row';;
                row.dataset.partId = part.id;
                let sequenceItems = [];
                if (isStamping) {
                    sequenceItems.push(`<div class="drop-target large" data-insert-index="0"></div>`);
                    part.sequence.forEach((color, index) => {
                        sequenceItems.push(`<div class="paint-step"><span>${sanitizeHTML(color)}</span></div>`);
                        sequenceItems.push(`<div class="drop-target small" data-insert-index="${index + 1}"></div>`);
                    });
                } else {
                    sequenceItems = part.sequence.map((color, index) => `
                        <div class="paint-step">
                            <button class="reorder-btn" data-dir="left" data-index="${index}" title="Move Left">←</button>
                            <span>${sanitizeHTML(color)}</span>
                            <button class="reorder-btn" data-dir="right" data-index="${index}" title="Move Right">→</button>
                            <span class="remove-step-btn" data-index="${index}" title="Remove step">×</span>
                        </div>`);
                }
                let selectOptions = state.paints.map(p => `<option value="${sanitizeHTML(p)}">${sanitizeHTML(p)}</option>`).join('') || '<option disabled>Add paints first</option>';
                row.innerHTML = `
                    <div class="part-name-label">${sanitizeHTML(part.name)}</div>
                    <div class="sequence-steps">${sequenceItems.join('')}</div>
                    <div class="add-paint-control"><select ${state.paints.length===0?'disabled':''}>${selectOptions}</select><button class="btn-add add-step-btn" ${state.paints.length===0?'disabled':''}>Add</button></div>`;
                partSequenceContainer.appendChild(row);
            });
        }
        
        function markAsUnsaved() { document.getElementById('save-btn').classList.add('unsaved'); }
        function invalidateSchedule() { if (scheduleData.steps.length > 0) outputSection.classList.add('invalidated'); }

        function enterStampMode() {
            if (state.paints.length === 0) { alert("Please add at least one paint color before using the Stamp Tool."); return; }
            state.stampMode.isActive = true;
            stampToolBtn.style.display = 'none';
            document.getElementById('stamp-tool-toolbar').style.display = 'flex';
            stampColorSelect.innerHTML = state.paints.map(p => `<option value="${sanitizeHTML(p)}">${sanitizeHTML(p)}</option>`).join('');
            state.stampMode.color = stampColorSelect.value;
            renderAll();
        }

        function exitStampMode() { state.stampMode.isActive = false; stampToolBtn.style.display = 'block'; document.getElementById('stamp-tool-toolbar').style.display = 'none'; renderAll(); }
        function handleStampColorChange() { state.stampMode.color = stampColorSelect.value; }
        function handleTitleChange() { state.title = titleInput.value; markAsUnsaved(); }
        
        function handleAddItems(inputEl, collection, createItem) {
            const values = inputEl.value.split(',').map(v => v.trim()).filter(Boolean);
            if (values.length === 0) return;
            values.forEach(value => { 
                const exists = collection.some(item => (item.name || item) === value);
                if (!exists) collection.push(createItem(value));
            });
            inputEl.value = ''; invalidateSchedule(); markAsUnsaved(); renderAll();
        }

        function handleAddPaint() { handleAddItems(paintInput, state.paints, value => value); }
        function handleAddPart() { handleAddItems(partInput, state.parts, value => ({ id: nextPartId++, name: value, sequence: [] })); }
        
        function handlePaintListClick(e) {
            if (!e.target.matches('.remove-btn')) return;
            const paintName = e.target.dataset.paintName;
            if (state.parts.some(p => p.sequence.includes(paintName))) {
                if (!confirm(`Warning: This will remove "${paintName}" from all part sequences. Proceed?`)) return;
                state.parts.forEach(part => { part.sequence = part.sequence.filter(color => color !== paintName); });
            }
            state.paints = state.paints.filter(p => p !== paintName);
            invalidateSchedule(); markAsUnsaved(); renderAll();
        }

        function handlePartListClick(e) {
            if (!e.target.matches('.remove-btn')) return;
            const partId = parseInt(e.target.dataset.partId);
            const part = state.parts.find(p => p.id === partId);
            if (part && confirm(`Remove part "${part.name}"?`)) {
                state.parts = state.parts.filter(p => p.id !== partId);
                invalidateSchedule(); markAsUnsaved(); renderAll();
            }
        }

        function handleNameEdit(e, listType) {
            const target = e.target;
            const saveEdit = () => {
                const newValue = target.textContent.trim();
                let oldValue, isDuplicate;
                
                if (listType === 'paint') {
                    oldValue = target.dataset.originalName;
                    isDuplicate = state.paints.includes(newValue);
                } else {
                    const partId = parseInt(target.dataset.partId);
                    const part = state.parts.find(p => p.id === partId);
                    if (!part) return;
                    oldValue = part.name;
                    isDuplicate = state.parts.some(p => p.name === newValue && p.id !== partId);
                }

                if (newValue === oldValue) return;
                if (!newValue) { alert("Name cannot be empty."); target.textContent = oldValue; return; }
                if (isDuplicate && newValue !== oldValue) { alert(`Name "${newValue}" already exists.`); target.textContent = oldValue; return; }
                
                if (listType === 'paint') {
                    const paintIndex = state.paints.indexOf(oldValue);
                    if (paintIndex > -1) {
                        state.paints[paintIndex] = newValue;
                        state.parts.forEach(part => {
                            part.sequence = part.sequence.map(color => color === oldValue ? newValue : color);
                        });
                    }
                } else {
                    const part = state.parts.find(p => p.id === parseInt(target.dataset.partId));
                    if (part) part.name = newValue;
                }
                invalidateSchedule(); markAsUnsaved(); renderAll();
            };

            if (e.type === 'keydown') {
                if (e.key === 'Enter') { e.preventDefault(); target.blur(); }
                if (e.key === 'Escape') {
                    target.textContent = listType === 'paint' ? target.dataset.originalName : state.parts.find(p => p.id === parseInt(target.dataset.partId))?.name;
                    target.blur();
                }
            } else if (e.type === 'blur') {
                saveEdit();
            }
        }
        
        function handleSequenceInteraction(e) {
            const partRow = e.target.closest('.part-sequence-row');
            if (!partRow) return;
            const part = state.parts.find(p => p.id === parseInt(partRow.dataset.partId));
            if (!part) return;
            if (state.stampMode.isActive && e.target.matches('.drop-target')) {
                const insertIndex = parseInt(e.target.dataset.insertIndex);
                part.sequence.splice(insertIndex, 0, state.stampMode.color);
                markAsUnsaved(); invalidateSchedule(); renderAll(); return;
            }
            let stateChanged = false;
            if (e.target.matches('.add-step-btn')) {
                const select = partRow.querySelector('select');
                if (select.value) { part.sequence.push(select.value); stateChanged = true; }
            } else if (e.target.matches('.remove-step-btn')) {
                part.sequence.splice(parseInt(e.target.dataset.index), 1); stateChanged = true;
            } else if (e.target.matches('.reorder-btn')) {
                const index = parseInt(e.target.dataset.index); const dir = e.target.dataset.dir;
                if (dir === 'left' && index > 0) { [part.sequence[index], part.sequence[index - 1]] = [part.sequence[index - 1], part.sequence[index]]; stateChanged = true; } 
                else if (dir === 'right' && index < part.sequence.length - 1) { [part.sequence[index], part.sequence[index + 1]] = [part.sequence[index + 1], part.sequence[index]]; stateChanged = true; }
            }
            if (stateChanged) { invalidateSchedule(); markAsUnsaved(); renderAll(); }
        }

        function generateOptimalOrder() {
            if (state.parts.filter(p => p.sequence.length === 0).length > 0) {
                if (!confirm(`Warning: Some parts have no paint sequence and will be ignored. Continue?`)) return;
            }
            _resetSchedule();
            
            let partsToProcess = JSON.parse(JSON.stringify(state.parts)).filter(p => p.sequence.length > 0).map(p => ({ ...p, currentStep: 0, originalSequence: p.sequence }));
            if (partsToProcess.length === 0) {
                outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">No parts with paint sequences.</p>'; return;
            }
            
            const partColorToStepIndex = new Map();
            let stepIdCounter = 0;
            while (partsToProcess.some(p => p.currentStep < p.sequence.length)) {
                const readyPartsByColor = new Map();
                partsToProcess.filter(p=>p.currentStep < p.sequence.length).forEach(part => {
                    const nextColor = part.sequence[part.currentStep];
                    if (!readyPartsByColor.has(nextColor)) readyPartsByColor.set(nextColor, []);
                    readyPartsByColor.get(nextColor).push(part);
                });
                
                let priorityChoices = [], lastStepChoices = [];
                for (const [color, partList] of readyPartsByColor.entries()) {
                    (partList.some(p => p.currentStep < p.sequence.length - 1) ? priorityChoices : lastStepChoices).push({ color, partList, count: partList.length });
                }
                const choices = priorityChoices.length > 0 ? priorityChoices : lastStepChoices;
                choices.sort((a, b) => b.count - a.count);
                if (choices.length === 0) break;
                
                const bestChoice = choices[0];
                const stepId = stepIdCounter++;
                scheduleData.steps.push({
                    id: stepId, color: bestChoice.color, partList: bestChoice.partList.map(p => p.name),
                    completedParts: bestChoice.partList.filter(p => p.currentStep + 1 === p.sequence.length).map(p => p.name), dependencies: new Set()
                });
                bestChoice.partList.forEach(part => { partColorToStepIndex.set(`${part.id}_${part.sequence[part.currentStep]}`, stepId); part.currentStep++; });
            }

            partsToProcess.forEach(part => {
                const sequenceStepIds = [];
                part.originalSequence.forEach(color => {
                    const stepId = partColorToStepIndex.get(`${part.id}_${color}`);
                    if(stepId !== undefined) sequenceStepIds.push(stepId);
                });
                scheduleData.partSequenceStepIds.set(part.name, sequenceStepIds);

                for(let i = 1; i < sequenceStepIds.length; i++) {
                    const prevStepId = sequenceStepIds[i-1];
                    const currentStepId = sequenceStepIds[i];
                    scheduleData.steps[currentStepId].dependencies.add(prevStepId);
                }
            });

            renderTargetPartSelector();
            updateScheduleView();
        }
        
        function renderTargetPartSelector() {
            targetPartSelect.innerHTML = '<option value="">Default (No Target)</option>';
            const sortedPartNames = Array.from(scheduleData.partSequenceStepIds.keys()).sort();
            sortedPartNames.forEach(name => {
                targetPartSelect.innerHTML += `<option value="${sanitizeHTML(name)}">${sanitizeHTML(name)}</option>`;
            });
            targetPartSelect.value = scheduleData.currentTargetPartName || "";
        }
        
        function updateTargetPath() {
            const { currentTargetPartName, partSequenceStepIds, steps } = scheduleData;
            scheduleData.targetPathStepIds.clear();
            if (!currentTargetPartName) return;

            const initialStepIds = partSequenceStepIds.get(currentTargetPartName);
            if (!initialStepIds) return;
            
            const stepMap = new Map(steps.map(s => [s.id, s]));
            const toProcess = [...initialStepIds];
            const processed = new Set();

            while(toProcess.length > 0) {
                const currentId = toProcess.pop();
                if (processed.has(currentId)) continue;
                processed.add(currentId);
                scheduleData.targetPathStepIds.add(currentId);
                const step = stepMap.get(currentId);
                if (step) {
                    step.dependencies.forEach(depId => toProcess.push(depId));
                }
            }
        }
        
        function isPartStartable(partName, stepId) {
            const { partSequenceStepIds, completedPartsByStepId } = scheduleData;
            const sequence = partSequenceStepIds.get(partName);
            if (!sequence) return false;
            
            const stepIndex = sequence.indexOf(stepId);
            if(stepIndex === -1) return false;
            if(stepIndex === 0) return true;

            const prereqStepId = sequence[stepIndex - 1];
            return completedPartsByStepId.get(prereqStepId)?.has(partName) ?? false;
        }

        function createStepWrapper(stepInfo) {
            const wrapper = document.createElement('div');
            wrapper.className = 'step-wrapper';

            let indicatorIcon = '🛑';
            let indicatorTitle = 'No parts are ready yet.';
            let indicatorClass = 'stop';
            
            const remainingPartsInStep = stepInfo.partList.length - stepInfo.completedCount;
            if (remainingPartsInStep > 0) {
                if (stepInfo.startableCount === remainingPartsInStep) {
                    indicatorIcon = '⭐'; indicatorTitle = 'All remaining parts are ready.'; indicatorClass = 'full';
                } else if (stepInfo.startableCount > 0) {
                    indicatorIcon = '▶️'; indicatorTitle = 'Some parts are ready.'; indicatorClass = 'partial';
                }
            }

            if (stepInfo.completedCount === stepInfo.partList.length) {
                wrapper.classList.add('is-completed');
            }
            if(scheduleData.targetPathStepIds.has(stepInfo.id)) {
                wrapper.classList.add('is-target-path');
            }
            
            let countText = '';
            if(stepInfo.startableCount > 0) {
               countText = ` (${stepInfo.startableCount} of ${remainingPartsInStep} ready)`;
            }
            
            wrapper.innerHTML = `
                <div class="step-header">
                    <span class="start-indicator ${indicatorClass}" title="${indicatorTitle}">${indicatorIcon}</span>
                    <span class="step-action">Load <code class="output-color-name">${sanitizeHTML(stepInfo.color)}</code>${countText}</span>
                    <label class="check-all-label">
                        <input type="checkbox" class="master-checkbox" data-step-id="${stepInfo.id}" ${stepInfo.startableCount === 0 ? 'disabled' : ''}> Check All Ready
                    </label>
                </div>
                <ul class="parts-checklist">${generatePartListHTML(stepInfo)}</ul>
                <div class="completion-notices">${generateCompletionNoticesHTML(stepInfo)}</div>`;

            return wrapper;
        }

        function createMergedStepWrapper(stepGroup) {
            const wrapper = document.createElement('div');
            wrapper.className = 'step-wrapper';
            
            const allOriginalIds = stepGroup.map(s => s.id);
            const isTargetPath = allOriginalIds.some(id => scheduleData.targetPathStepIds.has(id));
            if(isTargetPath) wrapper.classList.add('is-target-path');

            const totalStartable = stepGroup.reduce((sum, s) => sum + s.startableCount, 0);
            const totalRemaining = stepGroup.reduce((sum, s) => sum + (s.partList.length - s.completedCount), 0);
            
            let countText = ` (${totalStartable} of ${totalRemaining} ready)`;
            
            const masterCheck = `<label class="check-all-label">
                <input type="checkbox" class="master-checkbox" data-original-step-ids="${allOriginalIds.join(',')}" ${totalStartable === 0 ? 'disabled' : ''}> Check All Ready
            </label>`;
            
            let partListHTML = '';
            let noticesHTML = '';
            stepGroup.forEach(stepInfo => {
                partListHTML += generatePartListHTML(stepInfo);
                noticesHTML += generateCompletionNoticesHTML(stepInfo);
            });

            wrapper.innerHTML = `
                <div class="step-header">
                    <span class="start-indicator full" title="All remaining parts are ready.">⭐</span>
                    <span class="step-action">Load <code class="output-color-name">${sanitizeHTML(stepGroup[0].color)}</code>${countText}</span>
                    ${masterCheck}
                </div>
                <ul class="parts-checklist">${partListHTML}</ul>
                <div class="completion-notices">${noticesHTML}</div>`;
                
            return wrapper;
        }
        
        function generatePartListHTML(stepInfo) {
            return stepInfo.partList.sort().map(partName => {
                const isCompleted = scheduleData.completedPartsByStepId.get(stepInfo.id)?.has(partName) ?? false;
                const canStart = !isCompleted && isPartStartable(partName, stepInfo.id);
                let classes = 'part-item';
                if (isCompleted) classes += ' completed';
                if (!canStart && !isCompleted) classes += ' waiting';

                return `<li class="${classes}">
                    <label>
                        <input type="checkbox" class="part-checkbox" data-step-id="${stepInfo.id}" data-part-name="${sanitizeHTML(partName)}" ${isCompleted ? 'checked' : ''} ${!canStart && !isCompleted ? 'disabled' : ''}>
                        ${sanitizeHTML(partName)}
                    </label>
                </li>`;
            }).join('');
        }
        
        function generateCompletionNoticesHTML(stepInfo) {
            let html = '';
            const partsThatWillBeCompleted = stepInfo.completedParts.filter(p => !scheduleData.completedPartsByStepId.get(stepInfo.id)?.has(p));
            const partsAlreadyCompletedOnFinalStep = stepInfo.completedParts.filter(p => scheduleData.completedPartsByStepId.get(stepInfo.id)?.has(p));
            if (partsThatWillBeCompleted.length > 0) {
                 html += `<div class="completion-notice"><span>🏆</span><div>Will complete: <strong>${partsThatWillBeCompleted.map(sanitizeHTML).sort().join(', ')}</strong></div></div>`;
            }
            if (partsAlreadyCompletedOnFinalStep.length > 0) {
                html += `<div class="completion-notice"><span>✔️</span><div>Completed: <strong>${partsAlreadyCompletedOnFinalStep.map(sanitizeHTML).sort().join(', ')}</strong></div></div>`;
            }
            return html;
        }

        function updateScheduleView() {
            outputDiv.innerHTML = '';
            calculateProgress();

            const completedSteps = [], fullyReadySteps = [], partiallyReadySteps = [], waitingSteps = [];
            scheduleData.steps.forEach(step => {
                let completedCount = 0, startableCount = 0;
                step.partList.forEach(partName => {
                    const isCompleted = scheduleData.completedPartsByStepId.get(step.id)?.has(partName) ?? false;
                    if(isCompleted) {
                        completedCount++;
                    } else if(isPartStartable(partName, step.id)) {
                        startableCount++;
                    }
                });
                
                const stepInfo = { ...step, completedCount, startableCount };
                const remainingParts = step.partList.length - completedCount;

                if (remainingParts === 0) {
                    completedSteps.push(stepInfo);
                } else if (startableCount === remainingParts) {
                    fullyReadySteps.push(stepInfo);
                } else if (startableCount > 0) {
                    partiallyReadySteps.push(stepInfo);
                } else {
                    waitingSteps.push(stepInfo);
                }
            });
            
            const mergedReadyGroups = new Map();
            fullyReadySteps.forEach(stepInfo => {
                if(!mergedReadyGroups.has(stepInfo.color)) mergedReadyGroups.set(stepInfo.color, []);
                mergedReadyGroups.get(stepInfo.color).push(stepInfo);
            });
            
            // Render in order: Completed, Merged Ready, Partial, Waiting
            completedSteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
            mergedReadyGroups.forEach(group => outputDiv.appendChild(createMergedStepWrapper(group)));
            partiallyReadySteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
            waitingSteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
        }
        
        function calculateProgress() {
            const { partSequenceStepIds, completedPartsByStepId } = scheduleData;
            if (partSequenceStepIds.size === 0) {
                progressPercentageEl.textContent = ''; return;
            }
            let fullyCompletedPartsCount = 0;
            partSequenceStepIds.forEach((stepIds, partName) => {
                const isPartFullyComplete = stepIds.every(id => completedPartsByStepId.get(id)?.has(partName));
                if (isPartFullyComplete) fullyCompletedPartsCount++;
            });
            const percentage = Math.round((fullyCompletedPartsCount / partSequenceStepIds.size) * 100);
            progressPercentageEl.textContent = `Progress: ${percentage}%`;
        }

        function handleOutputChange(e) {
            const target = e.target;
            
            function togglePart(stepId, partName, shouldBeChecked) {
                 if (!scheduleData.completedPartsByStepId.has(stepId)) {
                    scheduleData.completedPartsByStepId.set(stepId, new Set());
                }
                const completedSet = scheduleData.completedPartsByStepId.get(stepId);
                if (shouldBeChecked) completedSet.add(partName); else completedSet.delete(partName);
            }

            if (target.matches('.part-checkbox')) {
                togglePart(parseInt(target.dataset.stepId), target.dataset.partName, target.checked);
                updateScheduleView();
            } else if (target.matches('.master-checkbox')) {
                const isChecking = target.checked;
                const stepIds = (target.dataset.originalStepIds || target.dataset.stepId).split(',').map(Number);

                stepIds.forEach(stepId => {
                    const step = scheduleData.steps.find(s => s.id === stepId);
                    if (!step) return;
                    step.partList.forEach(partName => {
                        if (!scheduleData.completedPartsByStepId.get(stepId)?.has(partName) && isPartStartable(partName, stepId)) {
                            togglePart(stepId, partName, isChecking);
                        }
                    });
                });
                updateScheduleView();
            }
        }

        function saveStateToHash() {
            const stateToSave = { title: titleInput.value.trim(), paints: state.paints, parts: state.parts };
            const jsonState = JSON.stringify(stateToSave);
            const base64State = btoa(unescape(encodeURIComponent(jsonState)));
            window.location.hash = base64State;
            navigator.clipboard.writeText(window.location.href).then(() => {
                const saveFeedback = document.getElementById('save-feedback');
                saveFeedback.textContent = 'Saved! Link copied to clipboard.';
                saveFeedback.style.opacity = '1';
                setTimeout(() => { saveFeedback.style.opacity = '0'; }, 3000);
            });
            document.getElementById('save-btn').classList.remove('unsaved');
        }

        function loadStateFromHash() {
            if (!window.location.hash) return false;
            try {
                const jsonState = decodeURIComponent(escape(atob(window.location.hash.substring(1))));
                const loadedState = JSON.parse(jsonState);
                if (loadedState && loadedState.paints && loadedState.parts) {
                    state = { ...loadedState, stampMode: { isActive: false, color: null } };
                    nextPartId = state.parts.reduce((max, p) => Math.max(max, p.id), -1) + 1;
                    return true;
                }
            } catch (e) {
                console.error("Failed to load state from hash:", e);
                alert("Could not load project. The link may be corrupted.");
            }
            return false;
        }

        function _resetSchedule() {
            scheduleData = { steps: [], completedPartsByStepId: new Map(), partSequenceStepIds: new Map(), currentTargetPartName: null, targetPathStepIds: new Set() };
            outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">Your schedule will appear here.</p>';
            progressPercentageEl.textContent = '';
            targetPartSelect.innerHTML = '';
            outputSection.classList.remove('invalidated');
        }

        function _performReset() {
            state = { title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } };
            nextPartId = 0;
            _resetSchedule();
            history.pushState("", document.title, window.location.pathname + window.location.search);
            exitStampMode();
        }

        function handleReset() { if (confirm('Reset everything? This will clear all data.')) { _performReset(); renderAll(); } }
        
        function loadInitialData() {
            _performReset();
            state.title = 'HG Gundam "Paint-by-Numbers"';
            state.paints.push('Primer', 'Frame Gray', 'Armor White', 'Gundam Blue', 'Fin Red', 'V-Fin Yellow', 'Gloss Clearcoat');
            state.parts.push(
                { id: nextPartId++, name: 'A-13 (Chest)', sequence: ['Primer', 'Gundam Blue', 'Armor White', 'Gloss Clearcoat'] },
                { id: nextPartId++, name: 'B-4 (Skirt)', sequence: ['Primer', 'Gundam Blue', 'Gloss Clearcoat']},
                { id: nextPartId++, name: 'C-2, C-5 (Leg Frame)', sequence: ['Frame Gray'] },
                { id: nextPartId++, name: 'D-1 (Shield)', sequence: ['Primer', 'Fin Red', 'Armor White', 'Gloss Clearcoat'] },
                { id: nextPartId++, name: 'F-9 (V-Fin)', sequence: ['Primer', 'V-Fin Yellow', 'Gloss Clearcoat'] }
            );
            renderAll();
            markAsUnsaved();
        }

        // EVENT LISTENERS
        addPaintBtn.addEventListener('click', handleAddPaint);
        paintInput.addEventListener('keydown', e => e.key === 'Enter' && handleAddPaint());
        paintList.addEventListener('click', handlePaintListClick);
        paintList.addEventListener('blur', (e) => handleNameEdit(e, 'paint'), true);
        paintList.addEventListener('keydown', (e) => handleNameEdit(e, 'paint'));
        addPartBtn.addEventListener('click', handleAddPart);
        partInput.addEventListener('keydown', e => e.key === 'Enter' && handleAddPart());
        partList.addEventListener('click', handlePartListClick);
        partList.addEventListener('blur', (e) => handleNameEdit(e, 'part'), true);
        partList.addEventListener('keydown', (e) => handleNameEdit(e, 'part'));
        partSequenceContainer.addEventListener('click', handleSequenceInteraction);
        titleInput.addEventListener('input', handleTitleChange);
        saveBtn.addEventListener('click', saveStateToHash);
        generateBtn.addEventListener('click', generateOptimalOrder);
        resetBtn.addEventListener('click', handleReset);
        stampToolBtn.addEventListener('click', enterStampMode);
        exitStampBtn.addEventListener('click', exitStampMode);
        stampColorSelect.addEventListener('change', handleStampColorChange);
        outputDiv.addEventListener('change', handleOutputChange);
        targetPartSelect.addEventListener('change', () => {
            scheduleData.currentTargetPartName = targetPartSelect.value || null;
            updateTargetPath();
            updateScheduleView();
        });
        
        // INITIALIZATION
        if (!loadStateFromHash()) loadInitialData();
        else { document.title = state.title + " - Paint Sequencer"; renderAll(); }
    });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Sequencer</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --surface-color: #ffffff;
            --text-color: #1c1e21;
            --text-secondary-color: #606770;
            --primary-color: #1877f2;
            --primary-hover-color: #166fe5;
            --secondary-color: #42b72a;
            --secondary-hover-color: #36a420;
            --danger-color: #fa383e;
            --warning-color: #ffc107;
            --warning-hover-color: #e0ac00;
            --border-color: #dddfe2;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        body { font-family: var(--font-family); line-height: 1.6; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 24px; }
        .container { max-width: 1200px; margin: 0 auto; display: flex; flex-direction: column; gap: 24px; }
        .card { background-color: var(--surface-color); box-shadow: var(--shadow); border-radius: 8px; padding: 20px; position: relative; }
        .card-header { display: flex; justify-content: space-between; align-items: baseline; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px; flex-wrap: wrap; gap: 10px; }
        .card-header h2 { border: none; padding: 0; margin: 0; }
        .card-header .legend { color: var(--text-secondary-color); font-size: 0.9em; white-space: nowrap; }
        .header-controls { display: contents; }
        #progress-percentage { font-weight: 600; color: var(--primary-color); margin-left: auto; padding: 0 10px;}
        #target-part-select { padding: 4px 8px; border-radius: 6px; border: 1px solid var(--border-color); font-size: 0.9em; }
        h1 { font-size: 1.8rem; margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px;}
        .title-input { font-size: 1.2rem; font-weight: 600; border: none; border-bottom: 2px solid transparent; width: 100%; padding: 4px; margin-bottom: 20px; transition: border-color 0.2s; }
        .title-input:focus { outline: none; border-bottom-color: var(--primary-color); }
        .setup-container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
        .input-group { display: flex; gap: 8px; margin-bottom: 15px; }
        .input-group input { flex-grow: 1; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 1rem; }
        .input-group button { white-space: nowrap; }
        button { padding: 10px 18px; background-color: var(--primary-color); color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: background-color 0.2s, opacity 0.2s; }
        button:hover { background-color: var(--primary-hover-color); }
        .btn-add, .btn-save.unsaved { background-color: var(--secondary-color); }
        .btn-add:hover, .btn-save.unsaved:hover { background-color: var(--secondary-hover-color); }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: #e03238; }
        .btn-warning { background-color: var(--warning-color); color: var(--text-color); }
        .btn-warning:hover { background-color: var(--warning-hover-color); }
        .item-list { list-style-type: none; padding: 0; display: flex; flex-wrap: wrap; gap: 10px; }
        .item-list li { display: flex; align-items: center; background-color: var(--bg-color); border-radius: 15px; padding: 5px 5px 5px 12px; font-size: 0.9rem; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .editable-name { cursor: text; padding: 2px 4px; border-radius: 3px; }
        .editable-name[contenteditable]:focus { outline: 2px solid var(--primary-color); background-color: #eaf3ff; }
        .remove-btn { background: #ccc; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; line-height: 20px; text-align: center; cursor: pointer; margin-left: 8px; font-weight: bold; transition: background-color 0.2s; }
        .remove-btn:hover { background-color: #a0a0a0; }
        .part-sequence-row { display: flex; align-items: center; gap: 15px; padding: 12px 0; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        .part-sequence-row:last-child { border-bottom: none; }
        .part-name-label { font-weight: 600; width: 150px; flex-shrink: 0; }
        .sequence-steps { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; flex-grow: 1; }
        .paint-step { display: flex; align-items: center; gap: 6px; background: #e4e6eb; border-radius: 6px; padding: 4px; position: relative; }
        .reorder-btn { display: inline-flex; align-items: center; justify-content: center; background: none; border: 1px solid #ccc; color: #888; border-radius: 50%; width: 22px; height: 22px; padding: 0; font-size: 14px; line-height: 1; text-align: center; cursor: pointer; transition: all 0.2s; }
        .reorder-btn:hover { background-color: #ddd; border-color: #aaa; color: #333; }
        .paint-step .remove-step-btn { color: #aaa; cursor: pointer; font-weight: bold; padding: 0 4px; }
        .paint-step .remove-step-btn:hover { color: var(--danger-color); }
        .add-paint-control select, #stamp-color-select { padding: 6px; border-radius: 6px; border: 1px solid var(--border-color); }
        .add-paint-control button { font-size: 0.9rem; padding: 6px 12px; }
        #stamp-tool-btn { background-color: var(--warning-color); color: var(--text-color); }
        #stamp-tool-btn:hover { background-color: var(--warning-hover-color); }
        #output { border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; background: #f8f9fa; min-height: 100px; transition: opacity 0.3s; }
        .step-wrapper { padding: 10px 0; border-bottom: 1px solid var(--border-color); transition: background-color 0.3s, border 0.3s; }
        .step-wrapper:last-child { border-bottom: none; }
        .step-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .start-indicator { font-size: 1.5rem; line-height: 1; width: 24px; text-align: center; cursor: help;}
        .start-indicator.success { color: var(--secondary-color); }
        .start-indicator.full { color: var(--warning-color); }
        .start-indicator.partial { color: var(--primary-color); }
        .start-indicator.stop { color: var(--danger-color); }
        .step-action { font-weight: 600; flex-grow: 1; }
        .check-all-label { white-space: nowrap; font-size: 0.9em; color: var(--text-secondary-color); }
        .check-all-label input { margin-right: 4px; }
        .output-color-name { background: #eee; padding: 2px 8px; border-radius: 4px; font-family: monospace; }
        .parts-checklist { list-style-type: none; padding-left: 48px; margin: 0 0 8px 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px; }
        .part-item { color: var(--text-color); }
        .part-item input { margin-right: 8px; transform: scale(1.1); }
        .part-item.waiting { color: var(--text-secondary-color); font-style: italic; }
        .part-item.waiting input { cursor: not-allowed; }
        .part-item.completed { text-decoration: line-through; }
        .step-wrapper.is-completed { opacity: 0.6; }
        .step-wrapper.is-target-path { border-left: 4px solid var(--warning-color); background-color: #fffbeb; padding-left: 10px; }
        .completion-notices { padding-left: 48px; font-size: 0.9em; }
        .completion-notice { display: flex; align-items: flex-start; color: var(--text-secondary-color); }
        .completion-notice span { line-height: 1.4; padding-right: 5px; }
        #output-section.invalidated #output { opacity: 0.4; }
        #output-section.invalidated::after { content: 'Schedule outdated. Please regenerate.'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(255, 255, 100, 0.85); border: 1px solid #e0e060; padding: 10px 20px; border-radius: 6px; font-weight: 600; text-align: center; }
        .main-controls { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 15px; }
        #save-feedback { color: var(--secondary-color); font-weight: 600; opacity: 0; transition: opacity 0.3s; }
        #stamp-tool-toolbar { display: none; background-color: var(--bg-color); padding: 15px; border-radius: 6px; margin-bottom: 20px; align-items: center; gap: 15px; border: 1px solid var(--border-color); }
        .stamp-mode-active #stamp-tool-toolbar { display: flex; }
        .stamp-mode-active .add-paint-control, .stamp-mode-active .reorder-btn, .stamp-mode-active .remove-step-btn { display: none; }
        .drop-target { border: 2px dashed var(--border-color); border-radius: 6px; cursor: pointer; transition: all 0.2s; position: relative; }
        .drop-target:hover { border-color: var(--warning-color); background-color: #fff8e1; }
        .drop-target::before { content: '+'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; color: #ccc; transition: color 0.2s; }
        .drop-target:hover::before { color: var(--warning-color); }
        .drop-target.large { width: 50px; height: 32px; }
        .drop-target.small { width: 20px; height: 32px; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 10; display: none; }
        .modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--surface-color); border-radius: 8px; z-index: 20; width: 90%; max-width: 800px; max-height: 90vh; display: flex; flex-direction: column; }
        .modal-header { padding: 15px 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .modal-header h3 { margin: 0; }
        .modal-close { font-size: 24px; font-weight: bold; background: none; border: none; cursor: pointer; padding: 0 5px; color: var(--text-color); }
        .modal-content { padding: 20px; overflow-y: auto; }
        .modal-tabs { display: flex; border-bottom: 1px solid var(--border-color); }
        .modal-tab { padding: 10px 15px; cursor: pointer; border: none; background: none; font-size: 1rem; border-bottom: 3px solid transparent; color: var(--text-color); }
        .modal-tab.active { border-bottom-color: var(--primary-color); font-weight: 600; }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }
        .tab-pane h4 { margin-top: 0; }
        .tab-pane textarea, .tab-pane pre { width: 100%; min-height: 200px; max-height: 40vh; font-family: monospace; font-size: 0.9rem; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; box-sizing: border-box; }
        .tab-pane pre { background-color: var(--bg-color); white-space: pre-wrap; word-wrap: break-word; overflow: auto; }
        .modal-footer { margin-top: 15px; display: flex; justify-content: flex-end; gap: 10px; }
        #json-status { margin-top: 10px; font-weight: bold; }
        #json-status.error { color: var(--danger-color); }
        #unused-items-warning { margin-top: 20px; padding: 15px; border-radius: 6px; background-color: #fffbe6; border: 1px solid var(--warning-color); }
        #unused-items-warning h4 { margin-top: 0; margin-bottom: 10px; color: #9c6f00; }
        #unused-items-warning ul { margin: 0; padding-left: 20px; font-size: 0.9em; }
        #part-status-container { margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color); }
        #part-status-container h3 { margin-top: 0; }
        #part-status-list { list-style-type: none; padding: 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; }
        .part-status-item { display: flex; flex-direction: column; gap: 8px; background-color: var(--bg-color); padding: 12px; border-radius: 6px; border-left: 4px solid var(--border-color); }
        .part-status-item.is-complete { border-left-color: var(--secondary-color); }
        .part-status-item .part-name { font-weight: 600; }
        .part-status-item progress { width: 100%; height: 8px; border-radius: 4px; }
        .part-status-item progress::-webkit-progress-bar { background-color: #e0e0e0; border-radius: 4px; }
        .part-status-item progress::-webkit-progress-value { background-color: var(--primary-color); border-radius: 4px; transition: width 0.3s ease; }
        .part-status-item.is-complete progress::-webkit-progress-value { background-color: var(--secondary-color); }
        .part-status-item .part-progress-info { display: flex; justify-content: space-between; font-size: 0.85em; color: var(--text-secondary-color); }
        .part-progress-info .status-ready { font-weight: 600; color: var(--secondary-color); }
        .part-progress-info .status-blocked { font-weight: 600; color: var(--danger-color); }
        
        @media (max-width: 900px) {
            .setup-container { grid-template-columns: 1fr; }
            .part-sequence-row { flex-direction: column; align-items: flex-start; }
            .main-controls { flex-direction: column; }
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="card">
            <h1>🎨 Paint Sequencer</h1>
            <input type="text" id="title-input" class="title-input" placeholder="Enter Project Title">
        </div>

        <div class="card">
            <div class="setup-container">
                <div id="paint-management">
                    <div class="card-header"><h2>Available Paints</h2></div>
                    <div class="input-group">
                        <input type="text" id="paint-input" placeholder="Add paints, comma-separated">
                        <button id="add-paint-btn" class="btn-add">Add</button>
                    </div>
                    <ul id="paint-list" class="item-list"></ul>
                </div>
                <div id="part-management">
                    <div class="card-header"><h2>📦 Parts to be Painted</h2></div>
                    <div class="input-group">
                        <input type="text" id="part-input" placeholder="Add parts, comma-separated">
                        <button id="add-part-btn" class="btn-add">Add</button>
                    </div>
                    <ul id="part-list" class="item-list"></ul>
                </div>
            </div>
        </div>

        <div class="card" id="sequence-card">
            <div class="card-header">
                <h2>Assign Paint Sequence</h2>
                <button id="stamp-tool-btn">🖌️ Stamp Tool</button>
            </div>
            <div id="stamp-tool-toolbar">
                <strong>Stamping with:</strong>
                <select id="stamp-color-select"></select>
                <button id="exit-stamp-btn" class="btn-danger">Finish Stamping</button>
            </div>
            <div id="part-sequence-container"><p style="color: var(--text-secondary-color);">Add parts to begin.</p></div>
            <div id="unused-items-warning" style="display: none;"></div>
        </div>
        
        <div class="card">
            <div class="main-controls">
                <button id="save-btn" class="btn-save">💾 Save & Copy Link</button>
                <button id="revert-btn" class="btn-danger" style="display: none;">↩️ Revert Changes</button>
                <button id="import-export-btn">📤 Import / Export</button>
                <button id="generate-btn">✨ Generate Optimal Order</button>
                <button id="reset-progress-btn" class="btn-warning">🔄 Reset Progress</button>
                <button id="reset-btn" class="btn-danger">💣 Reset All</button>
            </div>
            <p style="text-align: center; margin: 10px 0 0 0;"><span id="save-feedback"></span></p>
        </div>

        <div class="card" id="output-section">
            <div class="card-header">
                <div class="header-controls">
                    <h2>✔️ Optimized Schedule</h2>
                    <span id="progress-percentage"></span>
                    <select id="target-part-select" title="Select a part to highlight its critical path"></select>
                    <small class="legend">✔️ Completed, ⭐ Full, ▶️ Partial, 🛑 Blocked</small>
                </div>
            </div>
            <div id="output"><p style="color: var(--text-secondary-color);">Your schedule will appear here.</p></div>
            <div id="part-status-container">
                <h3>Part Status Tracker</h3>
                <ul id="part-status-list"><li style="color: var(--text-secondary-color);">Generate a schedule to see part status.</li></ul>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="json-modal-overlay">
        <div class="modal" id="json-modal">
            <div class="modal-header">
                <h3>Import / Export Project JSON</h3>
                <button class="modal-close" id="json-modal-close-btn">×</button>
            </div>
            <div class="modal-tabs">
                <button class="modal-tab active" data-tab="export">Export Project</button>
                <button class="modal-tab" data-tab="import">Import Project</button>
                <button class="modal-tab" data-tab="schema">JSON Schema</button>
            </div>
            <div class="modal-content">
                <div class="tab-pane active" id="tab-export">
                    <h4>Current Project JSON</h4>
                    <p>Copy this text to save your project definition to a file.</p>
                    <textarea id="json-export-area" readonly></textarea>
                    <div class="modal-footer">
                        <button id="copy-json-btn">Copy to Clipboard</button>
                    </div>
                </div>
                <div class="tab-pane" id="tab-import">
                    <h4>Import from Text</h4>
                    <textarea id="json-import-area" placeholder="Paste your project JSON here..."></textarea>
                    <h4>Import from URL</h4>
                    <div class="input-group">
                        <input type="url" id="json-import-url" placeholder="https://.../project.json">
                     </div>
                     <div id="json-status"></div>
                    <div class="modal-footer">
                        <button id="import-json-btn" class="btn-add">Load Project</button>
                    </div>
                </div>
                <div class="tab-pane" id="tab-schema">
                    <h4>Project File Schema</h4>
                    <p>Your JSON file should conform to this structure.</p>
                    <pre id="json-schema-area"></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        let state = { projectId: null, title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } };
        let paintIdMap = new Map();
        let nextPartId = 0;
        let nextPaintId = 0;
        let scheduleData = { steps: [], partToSequence: new Map(), completedTasks: new Set(), currentTargetPartName: null, targetPathStepIds: new Set() };
        
        // Element caching
        const saveBtn = document.getElementById('save-btn');
        const revertBtn = document.getElementById('revert-btn');
        const generateBtn = document.getElementById('generate-btn');
        const resetProgressBtn = document.getElementById('reset-progress-btn');
        const resetBtn = document.getElementById('reset-btn');
        const importExportBtn = document.getElementById('import-export-btn');
        const titleInput = document.getElementById('title-input');
        const paintList = document.getElementById('paint-list');
        const partList = document.getElementById('part-list');
        const partSequenceContainer = document.getElementById('part-sequence-container');
        const outputDiv = document.getElementById('output');
        const outputSection = document.getElementById('output-section');
        const progressPercentageEl = document.getElementById('progress-percentage');
        const targetPartSelect = document.getElementById('target-part-select');
        const stampToolBtn = document.getElementById('stamp-tool-btn');
        const jsonModalOverlay = document.getElementById('json-modal-overlay');
        const jsonModal = document.getElementById('json-modal');
        const jsonModalCloseBtn = document.getElementById('json-modal-close-btn');
        const unusedItemsWarningDiv = document.getElementById('unused-items-warning');
        
        const sanitizeHTML = str => String(str).replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[match]);
        const generateId = () => Math.random().toString(36).substring(2, 9);
        const getTaskKey = (partName, colorName, index) => `${partName}__${colorName}__${index}`;

        const naturalSort = (a, b) => {
            const re = /(\d+)|(\D+)/g;
            const aParts = String(a).match(re) || [];
            const bParts = String(b).match(re) || [];
            for (let i = 0; i < Math.min(aParts.length, bParts.length); i++) {
                const aPart = aParts[i];
                const bPart = bParts[i];
                if (!isNaN(aPart) && !isNaN(bPart)) {
                    const numDiff = parseInt(aPart, 10) - parseInt(bPart, 10);
                    if (numDiff !== 0) return numDiff;
                } else if (aPart !== bPart) {
                    return aPart.localeCompare(bPart);
                }
            }
            return aParts.length - bParts.length;
        };

        function updatePaintIdMap() { paintIdMap.clear(); state.paints.forEach(paint => paintIdMap.set(paint.id, paint.name)); }
        const getPaintNameById = (id) => paintIdMap.get(id) || 'Unknown Paint';
        
        const renderAll = () => { updatePaintIdMap(); renderTitle(); renderPaintList(); renderPartList(); renderSequenceBuilder(); };
        const renderTitle = () => { titleInput.value = state.title; document.title = state.title ? `${state.title} - Paint Sequencer` : "Paint Sequencer"; };
        
        const renderPaintList = () => {
             paintList.innerHTML = state.paints.map(p => `<li data-paint-id="${p.id}"><span class="editable-name" contenteditable="true" data-original-name="${sanitizeHTML(p.name)}">${sanitizeHTML(p.name)}</span><span class="remove-btn" data-paint-id="${p.id}" title="Remove Paint">×</span></li>`).join('');
        };
        const renderPartList = () => {
            partList.innerHTML = state.parts.map(p => `<li><span class="editable-name" contenteditable="true" data-part-id="${p.id}">${sanitizeHTML(p.name)}</span><span class="remove-btn" data-part-id="${p.id}" title="Remove Part">×</span></li>`).join('');
        };

        function renderUnusedItemsWarning() {
            const usedPaintIds = new Set();
            state.parts.forEach(part => { part.sequence.forEach(paintId => usedPaintIds.add(paintId)); });
            const unusedPaints = state.paints.filter(p => !usedPaintIds.has(p.id));
            const unusedParts = state.parts.filter(p => p.sequence.length === 0);

            if (unusedPaints.length === 0 && unusedParts.length === 0) {
                unusedItemsWarningDiv.style.display = 'none';
                return;
            }
            let html = '<h4>⚠️ Unused Items</h4>';
            if (unusedPaints.length > 0) { html += `<strong>Paints:</strong><ul>${unusedPaints.map(p => `<li>${sanitizeHTML(p.name)}</li>`).join('')}</ul>`; }
            if (unusedParts.length > 0) { html += `<strong>Parts:</strong><ul>${unusedParts.map(p => `<li>${sanitizeHTML(p.name)}</li>`).join('')}</ul>`; }
            unusedItemsWarningDiv.innerHTML = html;
            unusedItemsWarningDiv.style.display = 'block';
        }
        
        function renderSequenceBuilder() {
            const sequenceCard = document.getElementById('sequence-card');
            partSequenceContainer.innerHTML = '';
            if (state.parts.length === 0) {
                partSequenceContainer.innerHTML = '<p style="color: var(--text-secondary-color);">Add parts to begin.</p>';
                renderUnusedItemsWarning();
                return;
            }
            const isStamping = state.stampMode.isActive;
            sequenceCard.classList.toggle('stamp-mode-active', isStamping);

            state.parts.forEach(part => {
                const row = document.createElement('div');
                row.className = 'part-sequence-row';
                row.dataset.partId = part.id;
                let sequenceItems = [];
                const paintNameSequence = part.sequence.map(getPaintNameById);

                if (isStamping) {
                    sequenceItems.push(`<div class="drop-target large" data-insert-index="0"></div>`);
                    paintNameSequence.forEach((colorName, index) => {
                        sequenceItems.push(`<div class="paint-step"><span>${sanitizeHTML(colorName)}</span></div>`);
                        sequenceItems.push(`<div class="drop-target small" data-insert-index="${index + 1}"></div>`);
                    });
                } else {
                    sequenceItems = paintNameSequence.map((colorName, index) => `
                        <div class="paint-step">
                            <button class="reorder-btn" data-dir="left" data-index="${index}" title="Move Left">←</button>
                            <span>${sanitizeHTML(colorName)}</span>
                            <button class="reorder-btn" data-dir="right" data-index="${index}" title="Move Right">→</button>
                            <span class="remove-step-btn" data-index="${index}" title="Remove step">×</span>
                        </div>`);
                }
                let selectOptions = state.paints.map(p => `<option value="${p.id}">${sanitizeHTML(p.name)}</option>`).join('') || '<option disabled>Add paints first</option>';
                row.innerHTML = `
                    <div class="part-name-label">${sanitizeHTML(part.name)}</div>
                    <div class="sequence-steps">${sequenceItems.join('')}</div>
                    <div class="add-paint-control"><select ${state.paints.length===0?'disabled':''}>${selectOptions}</select><button class="btn-add add-step-btn" ${state.paints.length===0?'disabled':''}>Add</button></div>`;
                partSequenceContainer.appendChild(row);
            });
            renderUnusedItemsWarning();
        }
        
        function markAsUnsavedAndAutoSave() { saveBtn.classList.add('unsaved'); revertBtn.style.display = 'inline-block'; autoSaveProjectState(); }
        function markAsSaved() { saveBtn.classList.remove('unsaved'); revertBtn.style.display = 'none'; }
        function invalidateSchedule() { if (scheduleData.steps.length > 0) outputSection.classList.add('invalidated'); }

        function enterStampMode() {
            if (state.paints.length === 0) { alert("Please add at least one paint color before using the Stamp Tool."); return; }
            state.stampMode.isActive = true;
            document.getElementById('stamp-tool-btn').style.display = 'none';
            document.getElementById('stamp-tool-toolbar').style.display = 'flex';
            const stampColorSelect = document.getElementById('stamp-color-select');
            stampColorSelect.innerHTML = state.paints.map(p => `<option value="${p.id}">${sanitizeHTML(p.name)}</option>`).join('');
            state.stampMode.color = parseInt(stampColorSelect.value);
            renderAll();
        }

        function exitStampMode() { state.stampMode.isActive = false; document.getElementById('stamp-tool-btn').style.display = 'block'; document.getElementById('stamp-tool-toolbar').style.display = 'none'; renderAll(); }
        function handleStampColorChange(e) { state.stampMode.color = parseInt(e.target.value); }
        
        function handleTitleChange() { state.title = titleInput.value; renderTitle(); markAsUnsavedAndAutoSave(); }
        
        function handleAddItems(inputElId, collection, createItem, nameProp = 'name') {
            const inputEl = document.getElementById(inputElId);
            const values = inputEl.value.split(',').map(v => v.trim()).filter(Boolean);
            if (values.length === 0) return;
            values.forEach(value => { 
                const exists = collection.some(item => item[nameProp] === value);
                if (!exists) collection.push(createItem(value));
            });
            inputEl.value = ''; 
            invalidateSchedule(); 
            markAsUnsavedAndAutoSave(); 
            renderAll();
        }

        function handleAddPaint() { handleAddItems('paint-input', state.paints, value => ({ id: nextPaintId++, name: value }), 'name'); }
        function handleAddPart() { handleAddItems('part-input', state.parts, value => ({ id: nextPartId++, name: value, sequence: [] }), 'name'); }
        
        function handlePaintListClick(e) {
            if (!e.target.matches('.remove-btn')) return;
            const paintIdToRemove = parseInt(e.target.dataset.paintId);
            const paintToRemove = state.paints.find(p => p.id === paintIdToRemove);
            if (!paintToRemove) return;

            if (state.parts.some(p => p.sequence.includes(paintIdToRemove))) {
                if (!confirm(`Warning: This will remove "${paintToRemove.name}" from all part sequences. Proceed?`)) return;
                state.parts.forEach(part => { part.sequence = part.sequence.filter(pid => pid !== paintIdToRemove); });
            }
            state.paints = state.paints.filter(p => p.id !== paintIdToRemove);
            invalidateSchedule(); 
            markAsUnsavedAndAutoSave(); 
            renderAll();
        }

        function handlePartListClick(e) {
            if (!e.target.matches('.remove-btn')) return;
            const partId = parseInt(e.target.dataset.partId);
            const part = state.parts.find(p => p.id === partId);
            if (part && confirm(`Remove part "${part.name}"?`)) {
                state.parts = state.parts.filter(p => p.id !== partId);
                invalidateSchedule(); 
                markAsUnsavedAndAutoSave(); 
                renderAll();
            }
        }

        function handleNameEdit(e, listType) {
            const target = e.target;
            const saveEdit = () => {
                const newValue = target.textContent.trim();
                let oldValue;
                let isDuplicate = false; let idToUpdate;

                if (listType === 'paint') {
                    idToUpdate = parseInt(target.closest('li').dataset.paintId);
                    const paint = state.paints.find(p => p.id === idToUpdate);
                    if (!paint) return;
                    oldValue = paint.name;
                    isDuplicate = state.paints.some(p => p.name === newValue && p.id !== idToUpdate);
                } else { // part
                    idToUpdate = parseInt(target.dataset.partId);
                    const part = state.parts.find(p => p.id === idToUpdate);
                    if (!part) return;
                    oldValue = part.name;
                    isDuplicate = state.parts.some(p => p.name === newValue && p.id !== idToUpdate);
                }
                
                if (newValue === oldValue) return;
                if (!newValue) { alert("Name cannot be empty."); target.textContent = oldValue; return; }
                if (isDuplicate) { alert(`Name "${newValue}" already exists.`); target.textContent = oldValue; return; }
                
                const newCompletedTasks = new Set();
                scheduleData.completedTasks.forEach(taskKey => {
                    let [partName, paintName, index] = taskKey.split('__');
                    if (listType === 'paint' && paintName === oldValue) { paintName = newValue; } 
                    else if (listType === 'part' && partName === oldValue) { partName = newValue; }
                    newCompletedTasks.add(getTaskKey(partName, paintName, index));
                });
                scheduleData.completedTasks = newCompletedTasks;
                saveProgressToLocalStorage();

                if (listType === 'paint') {
                    const paint = state.paints.find(p => p.id === idToUpdate);
                    if (paint) paint.name = newValue;
                    scheduleData.steps.forEach(s => { if(s.color === oldValue) s.color = newValue; });
                } else { // part
                    const part = state.parts.find(p => p.id === idToUpdate);
                    if (part) part.name = newValue;
                    scheduleData.steps.forEach(s => { 
                        s.partList = s.partList.map(p => p.name === oldValue ? { ...p, name: newValue } : p);
                    });
                    scheduleData.partToSequence.forEach((seq, key) => { if(key === oldValue) { scheduleData.partToSequence.delete(key); scheduleData.partToSequence.set(newValue, seq); }});
                    if(scheduleData.currentTargetPartName === oldValue) scheduleData.currentTargetPartName = newValue;
                }
                
                markAsUnsavedAndAutoSave();
                renderAll();
                updateScheduleView();
            };

            if (e.type === 'keydown' && (e.key === 'Enter' || e.key === 'Escape')) {
                e.preventDefault();
                target.blur();
                if (e.key === 'Escape') target.textContent = target.dataset.originalName;
            } else if (e.type === 'blur') {
                saveEdit();
            }
        }
        
        function handleSequenceInteraction(e) {
            const partRow = e.target.closest('.part-sequence-row');
            if (!partRow) return;
            const part = state.parts.find(p => p.id === parseInt(partRow.dataset.partId));
            if (!part) return;
            if (state.stampMode.isActive && e.target.matches('.drop-target')) {
                const insertIndex = parseInt(e.target.dataset.insertIndex);
                part.sequence.splice(insertIndex, 0, state.stampMode.color);
                invalidateSchedule(); markAsUnsavedAndAutoSave(); renderAll(); return;
            }
            let stateChanged = false;
            if (e.target.matches('.add-step-btn')) {
                const select = partRow.querySelector('select');
                if (select.value) { part.sequence.push(parseInt(select.value)); stateChanged = true; }
            } else if (e.target.matches('.remove-step-btn')) {
                part.sequence.splice(parseInt(e.target.dataset.index), 1); stateChanged = true;
            } else if (e.target.matches('.reorder-btn')) {
                const index = parseInt(e.target.dataset.index); const dir = e.target.dataset.dir;
                if (dir === 'left' && index > 0) { [part.sequence[index], part.sequence[index - 1]] = [part.sequence[index - 1], part.sequence[index]]; stateChanged = true; } 
                else if (dir === 'right' && index < part.sequence.length - 1) { [part.sequence[index], part.sequence[index + 1]] = [part.sequence[index + 1], part.sequence[index]]; stateChanged = true; }
            }
            if (stateChanged) { invalidateSchedule(); markAsUnsavedAndAutoSave(); renderAll(); }
        }

        function generateOptimalOrder() {
            _resetSchedule(false);
            
            let partsToProcess = JSON.parse(JSON.stringify(state.parts)).filter(p => p.sequence.length > 0).map(p => ({ ...p, currentStep: 0 }));
            if (partsToProcess.length === 0) {
                outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">No parts with paint sequences.</p>'; 
                document.getElementById('part-status-list').innerHTML = `<li style="color: var(--text-secondary-color);">No sequenced parts to track.</li>`;
                return;
            }
            
            let stepIdCounter = 0;
            while (partsToProcess.some(p => p.currentStep < p.sequence.length)) {
                const readyPartsByColor = new Map();
                partsToProcess.filter(p => p.currentStep < p.sequence.length).forEach(part => {
                    const nextPaintId = part.sequence[part.currentStep];
                    if (!readyPartsByColor.has(nextPaintId)) readyPartsByColor.set(nextPaintId, []);
                    readyPartsByColor.get(nextPaintId).push(part);
                });
                
                let priorityChoices = [], lastStepChoices = [];
                for (const [paintId, partList] of readyPartsByColor.entries()) {
                    (partList.some(p => p.currentStep < p.sequence.length - 1) ? priorityChoices : lastStepChoices).push({ paintId, partList, count: partList.length });
                }
                const choices = priorityChoices.length > 0 ? priorityChoices : lastStepChoices;
                choices.sort((a, b) => b.count - a.count);
                if (choices.length === 0) break;
                
                const bestChoice = choices[0];
                const stepId = stepIdCounter++;
                const colorName = getPaintNameById(bestChoice.paintId);
                const stepParts = bestChoice.partList.map(p => ({ name: p.name, index: p.currentStep }));
                scheduleData.steps.push({ id: stepId, color: colorName, partList: stepParts });
                bestChoice.partList.forEach(part => { part.currentStep++; });
            }
            
            state.parts.forEach(part => { scheduleData.partToSequence.set(part.name, part.sequence.map(getPaintNameById)); });
            outputSection.classList.remove('invalidated');
            renderTargetPartSelector();
            updateScheduleView();
        }
        
        function renderTargetPartSelector() {
            targetPartSelect.innerHTML = '<option value="">Default (No Target)</option>';
            const sortedPartNames = Array.from(scheduleData.partToSequence.keys()).sort(naturalSort);
            sortedPartNames.forEach(name => { targetPartSelect.innerHTML += `<option value="${sanitizeHTML(name)}">${sanitizeHTML(name)}</option>`; });
            targetPartSelect.value = scheduleData.currentTargetPartName || "";
        }
        
        function updateTargetPath() {
            scheduleData.targetPathStepIds.clear();
            const { currentTargetPartName, partToSequence, steps } = scheduleData;
            if (!currentTargetPartName) return;

            const targetSequence = partToSequence.get(currentTargetPartName);
            if (!targetSequence) return;
            
            let requiredTasks = new Set(targetSequence.map((color, index) => getTaskKey(currentTargetPartName, color, index)));
            let toProcess = [...requiredTasks];
            while (toProcess.length > 0) {
                const taskKey = toProcess.pop();
                const [partName, , indexStr] = taskKey.split('__');
                const index = parseInt(indexStr);
                const sequence = partToSequence.get(partName);
                if(!sequence || index === 0) continue;
                const prereqIndex = index - 1;
                const prereqColor = sequence[prereqIndex];
                const prereqTaskKey = getTaskKey(partName, prereqColor, prereqIndex);
                if (!requiredTasks.has(prereqTaskKey)) { requiredTasks.add(prereqTaskKey); toProcess.push(prereqTaskKey); }
            }

            steps.forEach(step => {
                for (const partInfo of step.partList) {
                    if (requiredTasks.has(getTaskKey(partInfo.name, step.color, partInfo.index))) {
                        scheduleData.targetPathStepIds.add(step.id);
                        break;
                    }
                }
            });
        }
        
        function isPartStartable(partName, index) {
            if (index === 0) return true;
            const sequence = scheduleData.partToSequence.get(partName);
            if (!sequence || index >= sequence.length) return false;
            
            const prereqIndex = index - 1;
            const prereqColor = sequence[prereqIndex];
            return scheduleData.completedTasks.has(getTaskKey(partName, prereqColor, prereqIndex));
        }

        function createStepWrapper(stepInfo) {
            const wrapper = document.createElement('div');
            wrapper.className = 'step-wrapper';
            let indicatorIcon, indicatorTitle, indicatorClass;
            const remaining = stepInfo.partList.length - stepInfo.completedCount;

            if (remaining === 0) {
                indicatorIcon = '✔️'; indicatorTitle = 'Step completed.'; indicatorClass = 'success';
                wrapper.classList.add('is-completed');
            } else if (stepInfo.startableCount === remaining) {
                indicatorIcon = '⭐'; indicatorTitle = 'All remaining parts are ready.'; indicatorClass = 'full';
            } else if (stepInfo.startableCount > 0) {
                indicatorIcon = '▶️'; indicatorTitle = 'Some parts are ready.'; indicatorClass = 'partial';
            } else {
                indicatorIcon = '🛑'; indicatorTitle = 'No parts are ready yet.'; indicatorClass = 'stop';
            }
            if(scheduleData.targetPathStepIds.has(stepInfo.id)) wrapper.classList.add('is-target-path');
            
            let countText = (stepInfo.startableCount > 0 && remaining > 0) ? ` (${stepInfo.startableCount} of ${remaining} ready)` : '';
            wrapper.innerHTML = `
                <div class="step-header">
                    <span class="start-indicator ${indicatorClass}" title="${sanitizeHTML(indicatorTitle)}">${indicatorIcon}</span>
                    <span class="step-action">Load <code class="output-color-name">${sanitizeHTML(stepInfo.color)}</code>${countText}</span>
                    <label class="check-all-label">
                        <input type="checkbox" class="master-checkbox" data-step-id="${stepInfo.id}" ${stepInfo.startableCount === 0 ? 'disabled' : ''}> Check All Ready
                    </label>
                </div>
                <ul class="parts-checklist">${generatePartListHTML(stepInfo)}</ul>
                <div class="completion-notices">${generateCompletionNoticesHTML(stepInfo)}</div>`;
            return wrapper;
        }

        function createMergedStepWrapper(stepGroup) {
            const wrapper = document.createElement('div');
            wrapper.className = 'step-wrapper';
            const allOriginalIds = stepGroup.map(s => s.id);
            if(allOriginalIds.some(id => scheduleData.targetPathStepIds.has(id))) wrapper.classList.add('is-target-path');
            const totalStartable = stepGroup.reduce((sum, s) => sum + s.startableCount, 0);
            const totalRemaining = stepGroup.reduce((sum, s) => sum + (s.partList.length - s.completedCount), 0);
            let countText = ` (${totalStartable} of ${totalRemaining} ready)`;
            
            const masterCheck = `<label class="check-all-label"><input type="checkbox" class="master-checkbox" data-original-step-ids="${allOriginalIds.join(',')}" ${totalStartable === 0 ? 'disabled' : ''}> Check All Ready</label>`;
            const partListHTML = stepGroup.map(generatePartListHTML).join('');
            const noticesHTML = stepGroup.map(generateCompletionNoticesHTML).join('');

            wrapper.innerHTML = `
                <div class="step-header">
                    <span class="start-indicator full" title="All remaining parts are ready.">⭐</span>
                    <span class="step-action">Load <code class="output-color-name">${sanitizeHTML(stepGroup[0].color)}</code>${countText}</span>
                    ${masterCheck}
                </div>
                <ul class="parts-checklist">${partListHTML}</ul>
                <div class="completion-notices">${noticesHTML}</div>`;
            return wrapper;
        }
        
        function generatePartListHTML(stepInfo) {
            const sortedPartList = [...stepInfo.partList].sort((a,b) => naturalSort(a.name, b.name));

            return sortedPartList.map(partInfo => {
                const { name, index } = partInfo;
                const taskKey = getTaskKey(name, stepInfo.color, index);
                const isCompleted = scheduleData.completedTasks.has(taskKey);
                const canStart = !isCompleted && isPartStartable(name, index);
                let classes = 'part-item';
                if (isCompleted) classes += ' completed';
                if (!canStart && !isCompleted) classes += ' waiting';
                return `<li class="${classes}"><label>
                        <input type="checkbox" class="part-checkbox" data-part-name="${sanitizeHTML(name)}" data-color="${sanitizeHTML(stepInfo.color)}" data-index="${index}" 
                            ${isCompleted ? 'checked' : ''} ${!canStart && !isCompleted ? 'disabled' : ''}>
                        ${sanitizeHTML(name)}</label></li>`;
            }).join('');
        }
        
        function generateCompletionNoticesHTML(stepInfo) {
            let html = '';
            const willCompleteParts = [], didCompleteParts = [];
            stepInfo.partList.forEach(partInfo => {
                const { name, index } = partInfo;
                const sequence = scheduleData.partToSequence.get(name);
                if (sequence && index === sequence.length - 1) {
                    const taskKey = getTaskKey(name, stepInfo.color, index);
                    if (scheduleData.completedTasks.has(taskKey)) { didCompleteParts.push(name); } 
                    else { willCompleteParts.push(name); }
                }
            });
            if (willCompleteParts.length > 0) html += `<div class="completion-notice"><span>🏆</span><div>Will complete: <strong>${willCompleteParts.map(sanitizeHTML).sort(naturalSort).join(', ')}</strong></div></div>`;
            if (didCompleteParts.length > 0) html += `<div class="completion-notice"><span>✔️</span><div>Completed: <strong>${didCompleteParts.map(sanitizeHTML).sort(naturalSort).join(', ')}</strong></div></div>`;
            return html;
        }

        function renderPartStatusTracker() {
            const partStatusList = document.getElementById('part-status-list');
            const sequencedParts = state.parts.filter(p => p.sequence.length > 0);
            
            if (sequencedParts.length === 0) {
                 partStatusList.innerHTML = `<li style="color: var(--text-secondary-color);">No sequenced parts to track.</li>`;
                 return;
            }

            const items = sequencedParts.sort((a,b) => naturalSort(a.name, b.name)).map(part => {
                const sequence = scheduleData.partToSequence.get(part.name) || [];
                const totalSteps = sequence.length;
                
                const firstUncompletedIndex = sequence.findIndex((color, index) => !scheduleData.completedTasks.has(getTaskKey(part.name, color, index)));
                
                let progressValue, statusText, itemClass = '';

                if(firstUncompletedIndex === -1 && totalSteps > 0) {
                    progressValue = totalSteps;
                    statusText = '✅ Completed!';
                    itemClass = 'is-complete'
                } else if (totalSteps > 0) {
                    progressValue = firstUncompletedIndex;
                    const nextPaintName = sequence[firstUncompletedIndex];
                    const isReady = isPartStartable(part.name, firstUncompletedIndex);
                    statusText = `Next: <strong>${sanitizeHTML(nextPaintName)}</strong> ${isReady ? '<span class="status-ready">(Ready)</span>' : '<span class="status-blocked">(Blocked)</span>'}`;
                } else {
                    progressValue = 0;
                    statusText = 'No sequence defined.';
                }
                
                return `
                    <li class="part-status-item ${itemClass}">
                        <span class="part-name">${sanitizeHTML(part.name)}</span>
                        <progress value="${progressValue}" max="${totalSteps}"></progress>
                        <div class="part-progress-info">
                            <span>${progressValue}/${totalSteps} steps</span>
                            <span>${statusText}</span>
                        </div>
                    </li>`;
            });

            partStatusList.innerHTML = items.join('');
        }

        function updateScheduleView() {
            if (scheduleData.steps.length === 0) {
                renderPartStatusTracker(); // still render tracker even if schedule is empty
                return;
            }
            outputDiv.innerHTML = '';
            calculateProgress();

            const stepInfos = scheduleData.steps.map(step => {
                let completedCount = 0, startableCount = 0;
                step.partList.forEach(partInfo => {
                    const isCompleted = scheduleData.completedTasks.has(getTaskKey(partInfo.name, step.color, partInfo.index));
                    if(isCompleted) completedCount++;
                    else if(isPartStartable(partInfo.name, partInfo.index)) startableCount++;
                });
                return { ...step, completedCount, startableCount };
            });

            const completedSteps = [], fullyReadySteps = [], partiallyReadySteps = [], waitingSteps = [];
            stepInfos.forEach(s => {
                const remaining = s.partList.length - s.completedCount;
                if (remaining === 0) completedSteps.push(s);
                else if (s.startableCount === remaining) fullyReadySteps.push(s);
                else if (s.startableCount > 0) partiallyReadySteps.push(s);
                else waitingSteps.push(s);
            });
            
            const mergedReadyGroups = new Map();
            fullyReadySteps.forEach(s => {
                if(!mergedReadyGroups.has(s.color)) mergedReadyGroups.set(s.color, []);
                mergedReadyGroups.get(s.color).push(s);
            });
            
            outputDiv.innerHTML = '';
            completedSteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
            mergedReadyGroups.forEach(group => outputDiv.appendChild(createMergedStepWrapper(group)));
            partiallyReadySteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
            waitingSteps.forEach(s => outputDiv.appendChild(createStepWrapper(s)));
            
            renderPartStatusTracker();
        }
        
        function calculateProgress() {
            const { partToSequence, completedTasks } = scheduleData;
            if (!partToSequence || partToSequence.size === 0) { progressPercentageEl.textContent = ''; return;}
            
            let fullyCompletedPartsCount = 0;
            partToSequence.forEach((sequence, partName) => {
                if (sequence.every((color, index) => completedTasks.has(getTaskKey(partName, color, index)))) fullyCompletedPartsCount++;
            });
            const percentage = Math.round((fullyCompletedPartsCount / partToSequence.size) * 100);
            progressPercentageEl.textContent = `Progress: ${percentage}%`;
        }

        function handleOutputChange(e) {
            const target = e.target;
            function toggleTask(partName, color, index, shouldBeChecked) {
                const taskKey = getTaskKey(partName, color, index);
                if (shouldBeChecked) scheduleData.completedTasks.add(taskKey); else scheduleData.completedTasks.delete(taskKey);
            }

            if (target.matches('.part-checkbox')) {
                toggleTask(target.dataset.partName, target.dataset.color, parseInt(target.dataset.index), target.checked);
            } else if (target.matches('.master-checkbox')) {
                const isChecking = target.checked;
                const stepIds = (target.dataset.originalStepIds || target.dataset.stepId).split(',').map(Number);
                stepIds.forEach(stepId => {
                    const step = scheduleData.steps.find(s => s.id === stepId);
                    if (!step) return;
                    step.partList.forEach(partInfo => {
                        const { name, index } = partInfo;
                        if (!scheduleData.completedTasks.has(getTaskKey(name, step.color, index)) && isPartStartable(name, index)) {
                            toggleTask(name, step.color, index, isChecking);
                        }
                    });
                });
            } else { return; }
            
            saveProgressToLocalStorage();
            updateScheduleView();
        }

        // --- Persistence and Data Handling ---

        function autoSaveProjectState() {
            if (!state.projectId) return;
            const key = `paintSequencerProject_${state.projectId}`;
            try { localStorage.setItem(key, JSON.stringify(state)); } 
            catch (e) { console.error("Could not auto-save project state:", e); }
        }

        function saveProgressToLocalStorage() {
            if (!state.projectId) return;
            const key = `paintSequencerProgress_${state.projectId}`;
            try { localStorage.setItem(key, JSON.stringify(Array.from(scheduleData.completedTasks))); } 
            catch (e) { console.error("Could not save progress:", e); }
        }
        
        function clearAutoSavedProjectState() {
            if (!state.projectId) return;
            localStorage.removeItem(`paintSequencerProject_${state.projectId}`);
        }

        function saveStateToURL() {
            const json = JSON.stringify(state);
            const base64 = btoa(unescape(encodeURIComponent(json)));
            window.location.hash = base64;
            navigator.clipboard.writeText(window.location.href).then(() => {
                document.getElementById('save-feedback').textContent = 'Saved! Link copied to clipboard.';
                document.getElementById('save-feedback').style.opacity = '1';
                setTimeout(() => { document.getElementById('save-feedback').style.opacity = '0'; }, 3000);
            });
            clearAutoSavedProjectState();
            markAsSaved();
        }

        function decodeStateFromURL() {
            if (!window.location.hash) return null;
            try {
                const json = decodeURIComponent(escape(atob(window.location.hash.substring(1))));
                let loadedState = JSON.parse(json);
                if (loadedState && loadedState.paints && loadedState.parts) {
                    if (!loadedState.projectId) loadedState.projectId = generateId();
                    
                    if (loadedState.parts.length > 0 && loadedState.parts[0].sequence.length > 0 && typeof loadedState.parts[0].sequence[0] === 'string') {
                        const nameToIdMap = new Map(loadedState.paints.map(p => [p.name, p.id]));
                        loadedState.parts.forEach(part => {
                            part.sequence = part.sequence.map(name => nameToIdMap.get(name)).filter(id => id !== undefined);
                        });
                    }
                    return loadedState;
                }
            } catch (e) { console.error("Failed to load state from URL hash:", e); }
            return null;
        }

        function loadAutoSavedProjectState(projectId) {
            if (!projectId) return null;
            const key = `paintSequencerProject_${projectId}`;
            const savedData= localStorage.getItem(key);
            if (savedData) {
                try { return JSON.parse(savedData); }
                catch (e) { console.error("Failed to parse auto-saved project state:", e); return null; }
            }
            return null;
        }
        
        function loadProgressFromLocalStorage(projectId) {
            scheduleData.completedTasks.clear();
            if (!projectId) return;
            const savedData = localStorage.getItem(`paintSequencerProgress_${projectId}`);
            if (savedData) {
                try { scheduleData.completedTasks = new Set(JSON.parse(savedData)); } 
                catch(e) { console.error("Failed to parse progress from localStorage:", e); }
            }
        }

        function handleRevert() {
            if (confirm("Discard all unsaved changes and revert to the last saved version of this project?")) {
                clearAutoSavedProjectState();
                window.location.reload();
            }
        }

        function handleResetProgress() {
            if (confirm("Are you sure you want to reset all progress for this project? All checkboxes will be cleared.")) {
                scheduleData.completedTasks.clear();
                saveProgressToLocalStorage();
                updateScheduleView();
            }
        }

        function _resetSchedule(clearProgress = true) {
            scheduleData.steps = [];
            scheduleData.partToSequence.clear();
            scheduleData.currentTargetPartName = null;
            scheduleData.targetPathStepIds.clear();
            if (clearProgress && state.projectId) {
                scheduleData.completedTasks.clear();
                saveProgressToLocalStorage();
            }
            outputDiv.innerHTML = '<p style="color: var(--text-secondary-color);">Your schedule will appear here.</p>';
            progressPercentageEl.textContent = '';
            targetPartSelect.innerHTML = '';
            outputSection.classList.remove('invalidated');
            document.getElementById('part-status-list').innerHTML = `<li style="color: var(--text-secondary-color);">Generate a schedule to see part status.</li>`;
        }

        function _performReset(isNewProject = true) {
            if(state.projectId) {
                localStorage.removeItem(`paintSequencerProgress_${state.projectId}`);
                localStorage.removeItem(`paintSequencerProject_${state.projectId}`);
            }
            state = { projectId: generateId(), title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } };
            nextPartId = 0; nextPaintId = 0;
            _resetSchedule(true);
            if(isNewProject) history.pushState("", document.title, window.location.pathname + window.location.search);
            exitStampMode();
            markAsSaved();
        }

        function handleReset() { if (confirm('Reset everything? This will clear all data, including auto-saves and progress for this project.')) { _performReset(); renderAll(); } }
        
        // --- JSON Import/Export ---

        const projectSchema = {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "title": "Paint Sequencer Project",
            "description": "A project file for the Paint Sequencer application.",
            "type": "object",
            "properties": {
                "title": { "type": "string", "description": "The title of the project." },
                "paints": {
                    "type": "array",
                    "description": "A list of available paints.",
                    "items": { "type": "object", "properties": { "id": { "type": "number" }, "name": { "type": "string" } }, "required": ["id", "name"] }
                },
                "parts": {
                    "type": "array", "description": "A list of parts to be painted.",
                    "items": {
                        "type": "object",
                        "properties": { "id": { "type": "number" }, "name": { "type": "string" }, "sequence": { "type": "array", "items": { "type": "number" }, "description": "An array of paint IDs." } },
                        "required": ["id", "name", "sequence"]
                    }
                }
            },
            "required": ["title", "paints", "parts"]
        };


        function generateProjectJSON() {
            const projectData = {
                title: state.title,
                paints: state.paints.map(({ id, name }) => ({ id, name })),
                parts: state.parts.map(({ id, name, sequence }) => ({ id, name, sequence }))
            };
            return JSON.stringify(projectData, null, 2);
        }

        function openJsonModal() {
            document.getElementById('json-export-area').value = generateProjectJSON();
            document.getElementById('json-schema-area').textContent = JSON.stringify(projectSchema, null, 2);
            jsonModalOverlay.style.display = 'block';
        }
        function closeJsonModal() { jsonModalOverlay.style.display = 'none'; resetJsonImportStatus(); }

        function setupJsonModal() {
            importExportBtn.addEventListener('click', openJsonModal);
            jsonModalCloseBtn.addEventListener('click', closeJsonModal);
            jsonModalOverlay.addEventListener('click', (e) => { if (e.target === jsonModalOverlay) closeJsonModal(); });

            const tabs = jsonModal.querySelectorAll('.modal-tab');
            const panes = jsonModal.querySelectorAll('.tab-pane');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    panes.forEach(p => p.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(`tab-${tab.dataset.tab}`).classList.add('active');
                });
            });
            
            document.getElementById('copy-json-btn').addEventListener('click', () => {
                const area = document.getElementById('json-export-area');
                navigator.clipboard.writeText(area.value).then(() => alert('JSON copied to clipboard!'));
            });

            document.getElementById('import-json-btn').addEventListener('click', handleJsonImport);
        }

        function setJsonImportStatus(message, isError=false){
            const statusEl = document.getElementById('json-status');
            statusEl.textContent = message;
            statusEl.className = isError ? 'error' : 'success';
        }
        function resetJsonImportStatus(){ setJsonImportStatus('', false); }

        async function handleJsonImport() {
            resetJsonImportStatus();
            const jsonText = document.getElementById('json-import-area').value;
            const jsonUrl = document.getElementById('json-import-url').value;
            let projectData;

            try {
                if (jsonText) {
                    projectData = JSON.parse(jsonText);
                } else if (jsonUrl) {
                    setJsonImportStatus("Fetching from URL...");
                    const response = await fetch(jsonUrl);
                    if (!response.ok) throw new Error(`Failed to fetch from URL: ${response.statusText}`);
                    projectData = await response.json();
                } else { setJsonImportStatus("Please paste JSON or provide a URL.", true); return; }

                if (!projectData.title || !Array.isArray(projectData.paints) || !Array.isArray(projectData.parts)) { throw new Error("Invalid JSON structure. Missing required fields."); }

                if(confirm("This will replace your current project. All unsaved changes and progress will be lost. Continue?")) {
                    loadProjectFromData(projectData);
                    closeJsonModal();
                }
            } catch (error) { console.error("JSON Import Error:", error); setJsonImportStatus(`Error: ${error.message}`, true); }
        }
        
        function loadProjectFromData(data) { _performReset(false); state.title = data.title; state.paints = data.paints; state.parts = data.parts; markAsUnsavedAndAutoSave(); initializeAppLogic(); }
        
        // --- Initialization ---

        function initializeAppLogic() {
            nextPartId = state.parts.reduce((max, p) => Math.max(max, p.id), -1) + 1;
            nextPaintId = state.paints.reduce((max, p) => Math.max(max, p.id), -1) + 1;
            loadProgressFromLocalStorage(state.projectId);
            renderAll();
            generateOptimalOrder();
        }

        function initializeApp() {
            const getDefaultState = () => ({ projectId: generateId(), title: "Untitled Project", paints: [], parts: [], stampMode: { isActive: false, color: null } });
            let loadedState = null;
            let stateFromURL = decodeStateFromURL();
            if (stateFromURL) {
                let autoSavedState = loadAutoSavedProjectState(stateFromURL.projectId);
                loadedState = autoSavedState || stateFromURL;
                if(autoSavedState) markAsUnsavedAndAutoSave(); else markAsSaved();
            }
            
            if (loadedState) {
                state = { ...getDefaultState(), ...loadedState };
            } else {
                _performReset();
                state.title = 'HG Gundam "Paint-by-Numbers"';
                state.paints = [ {id: 0, name: 'Primer'}, {id: 1, name: 'Frame Gray'}, {id: 2, name: 'Armor White'}, {id: 3, name: 'Gundam Blue'}, {id: 4, name: 'Fin Red'}, {id: 5, name: 'V-Fin Yellow'}, {id: 6, name: 'Gloss Clearcoat'} ];
                state.parts.push( { id: 0, name: 'A-13 (Chest)', sequence: [0, 3, 2, 6] }, { id: 1, name: 'B-10 (Skirt)', sequence: [0, 2, 0, 3, 6]}, { id: 2, name: 'C-2, C-5 (Leg Frame)', sequence: [1] }, { id: 3, name: 'D-1 (Shield)', sequence: [0, 4, 2, 6] }, { id: 4, name: 'B-9 (V-Fin)', sequence: [0, 5, 6] } );
                markAsUnsavedAndAutoSave();
            }
            initializeAppLogic();
        }
        
        const eventListeners = [
            { el: document.getElementById('add-paint-btn'), event: 'click', handler: handleAddPaint },
            { el: document.getElementById('paint-input'), event: 'keydown', handler: e => e.key === 'Enter' && handleAddPaint() },
            { el: paintList, event: 'click', handler: handlePaintListClick },
            { el: paintList, event: 'blur', handler: (e) => handleNameEdit(e, 'paint'), capture: true },
            { el: paintList, event: 'keydown', handler: (e) => handleNameEdit(e, 'paint') },
            { el: document.getElementById('add-part-btn'), event: 'click', handler: handleAddPart },
            { el: document.getElementById('part-input'), event: 'keydown', handler: e => e.key === 'Enter' && handleAddPart() },
            { el: partList, event: 'click', handler: handlePartListClick },
            { el: partList, event: 'blur', handler: (e) => handleNameEdit(e, 'part'), capture: true },
            { el: partList, event: 'keydown', handler: (e) => handleNameEdit(e, 'part') },
            { el: partSequenceContainer, event: 'click', handler: handleSequenceInteraction },
            { el: titleInput, event: 'input', handler: handleTitleChange },
            { el: saveBtn, event: 'click', handler: saveStateToURL },
            { el: revertBtn, event: 'click', handler: handleRevert },
            { el: generateBtn, event: 'click', handler: generateOptimalOrder },
            { el: resetProgressBtn, event: 'click', handler: handleResetProgress },
            { el: resetBtn, event: 'click', handler: handleReset },
            { el: stampToolBtn, event: 'click', handler: enterStampMode },
            { el: document.getElementById('exit-stamp-btn'), event: 'click', handler: exitStampMode },
            { el: document.getElementById('stamp-color-select'), event: 'change', handler: handleStampColorChange },
            { el: outputDiv, event: 'change', handler: handleOutputChange },
            { el: targetPartSelect, event: 'change', handler: () => { scheduleData.currentTargetPartName = targetPartSelect.value || null; updateTargetPath(); updateScheduleView(); } }
        ];
        eventListeners.forEach(({el, event, handler, capture}) => el.addEventListener(event, handler, capture || false));
        
        setupJsonModal();
        initializeApp();
    });
    </script>
</body>
</html>